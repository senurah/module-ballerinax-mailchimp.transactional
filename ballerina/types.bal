// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/constraint;
import ballerina/data.jsondata;
import ballerina/http;

public type MessagesSendTemplateBody record {
    # enable a background sending mode that is optimized for bulk sending. In async mode, messages/send will immediately return a status of "queued" for every recipient. To handle rejections when sending in async mode, set up a webhook for the 'reject' event. Defaults to false for messages with no more than 10 recipients; messages with more than 10 recipients are always sent asynchronously, regardless of the value of async
    boolean async?;
    # the immutable slug of a template that exists in the user's account. Make sure you don't use the template name as this one might change
    @jsondata:Name {value: "template_name"}
    string templateName;
    # an array of template content to send. Each item in the array should be a struct with two keys - name: the name of the content block to set the content for, and content: the actual content to put into the block
    @jsondata:Name {value: "template_content"}
    MessagessendTemplateTemplateContent[] templateContent;
    # the name of the dedicated ip pool that should be used to send the message. If you do not have any dedicated IPs, this parameter has no effect. If you specify a pool that does not exist, your default pool will be used instead
    @jsondata:Name {value: "ip_pool"}
    string ipPool?;
    # when this message should be sent as a UTC timestamp in YYYY-MM-DD HH:MM:SS format. If you specify a time in the past, the message will be sent immediately; for future dates, you're limited to one year from the date of scheduling
    @jsondata:Name {value: "send_at"}
    string sendAt?;
    # the other information on the message to send - same as /messages/send, but without the html content
    MessagessendTemplateMessage message;
    # a valid api key
    string 'key;
};

public type TemplatesRenderBody record {
    # the immutable name of a template that exists in the user's account
    @jsondata:Name {value: "template_name"}
    string templateName;
    # an array of template content to render. Each item in the array should be a struct with two keys - name: the name of the content block to set the content for, and content: the actual content to put into the block
    @jsondata:Name {value: "template_content"}
    TemplatesrenderTemplateContent[] templateContent;
    # optional merge variables to use for injecting merge field content. If this is not provided, no merge fields will be replaced
    @jsondata:Name {value: "merge_vars"}
    TemplatesrenderMergeVars[] mergeVars?;
    # a valid api key
    string 'key;
};

public type ExportsInfoBody record {
    # an export job identifier
    string id;
    # a valid api key
    string 'key;
};

# a single supported attachment
public type MessagessendMessageAttachments record {
    # the file name of the attachment
    string name?;
    # the MIME type of the attachment
    string 'type?;
    # the content of the attachment as a base64-encoded string
    string content?;
};

public type MetadataDeleteBody record {
    # the unique identifier of the metadata field to update
    string name;
    # a valid api key
    string 'key;
};

# Provides a set of configurations for controlling the behaviours when communicating with a remote HTTP endpoint.
@display {label: "Connection Config"}
public type ConnectionConfig record {|
    # The HTTP version understood by the client
    http:HttpVersion httpVersion = http:HTTP_2_0;
    # Configurations related to HTTP/1.x protocol
    http:ClientHttp1Settings http1Settings = {};
    # Configurations related to HTTP/2 protocol
    http:ClientHttp2Settings http2Settings = {};
    # The maximum time to wait (in seconds) for a response before closing the connection
    decimal timeout = 30;
    # The choice of setting `forwarded`/`x-forwarded` header
    string forwarded = "disable";
    # Configurations associated with Redirection
    http:FollowRedirects followRedirects?;
    # Configurations associated with request pooling
    http:PoolConfiguration poolConfig?;
    # HTTP caching related configurations
    http:CacheConfig cache = {};
    # Specifies the way of handling compression (`accept-encoding`) header
    http:Compression compression = http:COMPRESSION_AUTO;
    # Configurations associated with the behaviour of the Circuit Breaker
    http:CircuitBreakerConfig circuitBreaker?;
    # Configurations associated with retrying
    http:RetryConfig retryConfig?;
    # Configurations associated with cookies
    http:CookieConfig cookieConfig?;
    # Configurations associated with inbound response size limits
    http:ResponseLimitConfigs responseLimits = {};
    # SSL/TLS-related options
    http:ClientSecureSocket secureSocket?;
    # Proxy server related options
    http:ProxyConfig proxy?;
    # Provides settings related to client socket configuration
    http:ClientSocketConfig socketConfig = {};
    # Enables the inbound payload validation functionality which provided by the constraint package. Enabled by default
    boolean validation = true;
    # Enables relaxed data binding on the client side. When enabled, `nil` values are treated as optional, 
    # and absent fields are handled as `nilable` types. Enabled by default.
    boolean laxDataBinding = true;
|};

# information on an individual click
public type MessagessearchClicksDetail record {
    # the IP address that generated the click
    string ip?;
    # the approximate region and country that the clicking IP is located
    string location?;
    # the email client or browser data of the click
    string ua?;
    # the URL that was clicked on
    string url?;
    # the unix timestamp from when the message was clicked
    int ts?;
};

public type SendersInfoBody record {
    # the email address of the sender
    string address;
    # a valid api key
    string 'key;
};

# information about a specific smtp event
public type InlineResponse20032SmtpEvents record {
    # the SMTP response from the recipient's server
    string diag?;
    # the message's state as a result of this event
    string 'type?;
    # the Unix timestamp when the event occured
    int ts?;
};

public type TemplatesTimeSeriesBody record {
    # the name of an existing template
    string name;
    # a valid api key
    string 'key;
};

public type MessagessendMessageVars record {
    # the merge variable's name. Merge variable names are case-insensitive and may not start with _
    string name?;
    # the merge variable's content
    string content?;
};

public type InboundAddDomainBody record {
    # a domain name; Validation: strip_tags, required
    string domain;
    # a valid api key
    string 'key;
};

# stats with this tag in the last 90 days
public type InlineResponse20059StatsLast90Days record {
    # the number of emails rejected for sending this sender in the last 90 days
    int rejects?;
    # the number of emails hard bounced with this tag in the last 90 days
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent with this tag in the last 90 days
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes with this tag in the last 90 days
    int unsubs?;
    # the number of spam complaints with this tag in the last 90 days
    int complaints?;
    # the number of times emails have been opened with this tag in the last 90 days
    int opens?;
    # the number of URLs that have been clicked with this tag in the last 90 days
    int clicks?;
    # the number of emails soft bounced with this tag in the last 90 days
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent with this tag in the last 90 days
    int sent?;
    # the number of unique opens for emails sent with this tag in the last 90 days
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# information about the domain
public type InlineResponse2009 record {
    # the domain name that is accepting mail
    string domain?;
    # true if this inbound domain has successfully set up an MX record to deliver mail to the Mandrill servers
    @jsondata:Name {value: "valid_mx"}
    boolean validMx?;
    # the date and time that the inbound domain was added as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
};

# the individual domain info
public type InlineResponse2008 record {
    # the domain name that is accepting mail
    string domain?;
    # true if this inbound domain has successfully set up an MX record to deliver mail to the Mandrill servers
    @jsondata:Name {value: "valid_mx"}
    boolean validMx?;
    # the date and time that the inbound domain was added as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
};

# an aggregate summary of the account's sending stats
public type InlineResponse20072Stats record {
    @jsondata:Name {value: "last_7_days"}
    InlineResponse20072StatsLast7Days last7Days?;
    @jsondata:Name {value: "all_time"}
    InlineResponse20072StatsAllTime allTime?;
    # stats for this user so far today
    InlineResponse20072StatsToday today?;
    @jsondata:Name {value: "last_90_days"}
    InlineResponse20072StatsLast90Days last90Days?;
    @jsondata:Name {value: "last_30_days"}
    InlineResponse20072StatsLast30Days last30Days?;
    @jsondata:Name {value: "last_60_days"}
    InlineResponse20072StatsLast60Days last60Days?;
};

# a single global merge variable
public type MessagessendMessageGlobalMergeVars record {
    # the global merge variable's name. Merge variable names are case-insensitive and may not start with _
    string name?;
    # the global merge variable's content
    string content?;
};

public type InboundRoutesBody record {
    # the domain to check
    string domain;
    # a valid api key
    string 'key;
};

public type IpsDeletePoolBody record {
    # the name of the pool to delete
    string pool;
    # a valid api key
    string 'key;
};

# details about the domain's DKIM record
public type InlineResponse20045Dkim record {
    # whether the domain's DKIM record is valid for use with Mandrill
    boolean valid?;
    # when the domain's DKIM record will be considered valid for use with Mandrill as a UTC string in YYYY-MM-DD HH:MM:SS format. If set, this indicates that the record is valid now, but was previously invalid, and Mandrill will wait until the record's TTL elapses to start using it
    @jsondata:Name {value: "valid_after"}
    string validAfter?;
    # an error describing the DKIM record, or null if the record is correct
    string 'error?;
};

# stats for this sender in the last 7 days
public type InlineResponse20048StatsLast7Days record {
    # the number of emails rejected for sending this sender in the last 7 days
    int rejects?;
    # the number of emails hard bounced for this sender in the last 7 days
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent for this sender in the last 7 days
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes for this sender in the last 7 days
    int unsubs?;
    # the number of spam complaints for this sender in the last 7 days
    int complaints?;
    # the number of times emails have been opened for this sender in the last 7 days
    int opens?;
    # the number of URLs that have been clicked for this sender in the last 7 days
    int clicks?;
    # the number of emails soft bounced for this sender in the last 7 days
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent for this sender in the last 7 days
    int sent?;
    # the number of unique opens for emails sent for this sender in the last 7 days
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

public type RejectsAddBody record {
    # an optional unique identifier for the subaccount to limit the denylist entry
    @constraint:String {maxLength: 255}
    string subaccount?;
    # an optional comment describing the rejection
    string comment?;
    # a valid api key
    string 'key;
    # an email address to block
    string email;
};

# stats for this user in the last 60 days
public type InlineResponse20072StatsLast60Days record {
    # the number of emails rejected for sending this sender in the last 60 days
    int rejects?;
    # the number of emails hard bounced for this user in the last 60 days
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent for this user in the last 60 days
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes for this user in the last 60 days
    int unsubs?;
    # the number of spam complaints for this user in the last 60 days
    int complaints?;
    # the number of times emails have been opened for this user in the last 60 days
    int opens?;
    # the number of URLs that have been clicked for this user in the last 60 days
    int clicks?;
    # the number of emails soft bounced for this user in the last 60 days
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent for this user in the last 60 days
    int sent?;
    # the number of unique opens for emails sent for this user in the last 60 days
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# information about each dedicated IP
public type IpslistPoolsIps record {
    @jsondata:Name {value: "custom_dns"}
    IpslistCustomDns customDns?;
    # the ip address
    string ip?;
    # the domain name (reverse dns) of this dedicated IP
    string domain?;
    # the name of the pool that this dedicated IP belongs to
    string pool?;
    # the date and time that the dedicated IP was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # information about the ip's warmup status
    IpslistWarmup warmup?;
};

public type InboundCheckDomainBody record {
    # an existing inbound domain
    string domain;
    # a valid api key
    string 'key;
};

# information about the ip's warmup status
public type IpslistWarmup record {
    # the end date and time for the warmup process as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "end_at"}
    string endAt?;
    # whether the ip is currently in warmup mode
    @jsondata:Name {value: "warming_up"}
    boolean warmingUp?;
    # the start time for the warmup process as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "start_at"}
    string startAt?;
};

# the information for each allowlist entry
public type InlineResponse2001 record {
    # when the email was added to the allowlist
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # a description of why the email was allowlisted
    string detail?;
    # the email that is allowlisted
    string email?;
};

# the information about the export
public type InlineResponse2003 record {
    # the url for the export job's results, if the job is completed
    @jsondata:Name {value: "result_url"}
    string resultUrl?;
    # the date and time that the export job was finished as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "finished_at"}
    string finishedAt?;
    # the date and time that the export job was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the unique identifier for this Export. Use this identifier when checking the export job's status
    string id?;
    # the export job's state - waiting, working, complete, error, or expired
    string state?;
    # the type of the export job - activity, reject, or allowlist
    string 'type?;
};

public type ExportsRejectsBody record {
    # an optional email address to notify when the export job has finished
    @jsondata:Name {value: "notify_email"}
    string notifyEmail?;
    # a valid api key
    string 'key;
};

# a status object containing the address and whether the deletion succeeded
public type InlineResponse2002 record {
    # whether the address was deleted successfully
    boolean deleted?;
    # the email address that was removed from the denylist
    string email?;
};

public type TemplatesAddBody record {
    # a default sending address for emails sent using this template
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # the HTML code for the template with mc:edit attributes for the editable elements
    string code?;
    # a default subject line to be used
    string subject?;
    # set to false to add a draft template without publishing
    boolean publish?;
    # the name for the new template - must be unique
    string name;
    # a default text part to be used when sending with this template
    string text?;
    # a default from name to be used
    @jsondata:Name {value: "from_name"}
    string fromName?;
    # a valid api key
    string 'key;
    # an optional array of up to 10 labels to use for filtering templates
    @constraint:Array {maxLength: 10}
    TemplatesAddBodyLabelsItemsString[] labels?;
};

# information about the rejects export job that was started
public type InlineResponse2005 record {
    # the url for the export job's results, if the job is completed
    @jsondata:Name {value: "result_url"}
    string resultUrl?;
    # the date and time that the export job was finished as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "finished_at"}
    string finishedAt?;
    # the date and time that the export job was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the unique identifier for this Export. Use this identifier when checking the export job's status
    string id?;
    # the export job's state - waiting, working, complete, error, or expired
    string state?;
    # the type of the export job - activity, reject, or whitelist
    string 'type?;
};

# the individual export info
public type InlineResponse2004 record {
    # the url for the export job's results, if the job is completed
    @jsondata:Name {value: "result_url"}
    string resultUrl?;
    # the date and time that the export job was finished as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "finished_at"}
    string finishedAt?;
    # the date and time that the export job was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the unique identifier for this Export. Use this identifier when checking the export job's status
    string id?;
    # the export job's state - waiting, working, complete, error, or expired
    string state?;
    # the type of the export job - activity, reject, or allowlist
    string 'type?;
};

# information about the activity export job that was started
public type InlineResponse2007 record {
    # the url for the export job's results, if the job is complete
    @jsondata:Name {value: "result_url"}
    string resultUrl?;
    # the date and time that the export job was finished as a UTC string in YYYY-MM-DD HH:MM:SS format, or null for jobs that have not run
    @jsondata:Name {value: "finished_at"}
    string finishedAt?;
    # the date and time that the export job was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the unique identifier for this Export. Use this identifier when checking the export job's status
    string id?;
    # the export job's state
    string state?;
    # the type of the export job
    string 'type?;
};

# stats for this user in the last 90 days
public type InlineResponse20072StatsLast90Days record {
    # the number of emails rejected for sending this sender in the last 90 days
    int rejects?;
    # the number of emails hard bounced for this user in the last 90 days
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent for this user in the last 90 days
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes for this user in the last 90 days
    int unsubs?;
    # the number of spam complaints for this user in the last 90 days
    int complaints?;
    # the number of times emails have been opened for this user in the last 90 days
    int opens?;
    # the number of URLs that have been clicked for this user in the last 90 days
    int clicks?;
    # the number of emails soft bounced for this user in the last 90 days
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent for this user in the last 90 days
    int sent?;
    # the number of unique opens for emails sent for this user in the last 90 days
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# information about the allowlist export job that was started
public type InlineResponse2006 record {
    # the url for the export job's results, if the job is complete
    @jsondata:Name {value: "result_url"}
    string resultUrl?;
    # the date and time that the export job was finished as a UTC string in YYYY-MM-DD HH:MM:SS format, or null for jobs that have not run
    @jsondata:Name {value: "finished_at"}
    string finishedAt?;
    # the date and time that the export job was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the unique identifier for this Export. Use this identifier when checking the export job's status
    string id?;
    # the export job's state
    string state?;
    # the type of the export job
    string 'type?;
};

# information about an individual image
public type InlineResponse20034Images record {
    # the Content-ID of the embedded image
    string name?;
    # the MIME type of the image
    string 'type?;
    # the content of the image as a base64 encoded string
    string content?;
};

# the injection of a single piece of content into a single editable region
public type TemplatesrenderTemplateContent record {
    # the name of the mc:edit editable region to inject into
    string name;
    # the content to inject
    string content;
};

public type WebhooksUpdateBody record {
    # an optional description of the webhook
    string description?;
    # the unique identifier of a webhook belonging to this account
    decimal id;
    # a valid api key
    string 'key;
    # the URL to POST batches of events. Requires webhook to exist
    string url;
    # an optional list of events that will be posted to the webhook
    record {}[] events?;
};

public type RejectsListBody record {
    # an optional unique identifier for the subaccount to limit the denylist
    @constraint:String {maxLength: 255}
    string subaccount?;
    # whether to include rejections that have already expired
    @jsondata:Name {value: "include_expired"}
    boolean includeExpired?;
    # a valid api key
    string 'key;
    # an optional email address to search by
    string email?;
};

# an aggregate summary of the tag's sending stats
public type InlineResponse20059Stats record {
    @jsondata:Name {value: "last_7_days"}
    InlineResponse20059StatsLast7Days last7Days?;
    # stats with this tag so far today
    InlineResponse20059StatsToday today?;
    @jsondata:Name {value: "last_90_days"}
    InlineResponse20059StatsLast90Days last90Days?;
    @jsondata:Name {value: "last_30_days"}
    InlineResponse20059StatsLast30Days last30Days?;
    @jsondata:Name {value: "last_60_days"}
    InlineResponse20059StatsLast60Days last60Days?;
};

# an associated array containing the recipient's unique metadata. If a key exists in both the per-recipient metadata and the global metadata, the per-recipient metadata will be used
public type MessagessendMessageValues record {
    @jsondata:Name {value: "user_id"}
    int userId?;
};

# the requested template information
public type InlineResponse20061 record {
    # the full HTML code of the template, with mc:edit attributes marking the editable elements - draft version
    string code?;
    # the default sender address for the template, if provided - draft version
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # the subject line of the template, if provided - draft version
    string subject?;
    # the default sender address for the template, if provided
    @jsondata:Name {value: "publish_from_email"}
    string publishFromEmail?;
    # the date and time the template was first created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the default sender from name for the template, if provided - draft version
    @jsondata:Name {value: "from_name"}
    string fromName?;
    # indicates if the template is malformed or corrupt
    @jsondata:Name {value: "is_broken_template"}
    boolean isBrokenTemplate?;
    # the list of labels applied to the template
    string[] labels?;
    # the same as the template name - kept as a separate field for backwards compatibility
    @jsondata:Name {value: "publish_name"}
    string publishName?;
    # the subject line of the template, if provided
    @jsondata:Name {value: "publish_subject"}
    string publishSubject?;
    # the date and time the template was last modified as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "updated_at"}
    string updatedAt?;
    # the default text part of messages sent with the template, if provided
    @jsondata:Name {value: "publish_text"}
    string publishText?;
    # the name of the template
    string name?;
    # the default text part of messages sent with the template, if provided - draft version
    string text?;
    # the default sender from name for the template, if provided
    @jsondata:Name {value: "publish_from_name"}
    string publishFromName?;
    # the date and time the template was last published as a UTC string in YYYY-MM-DD HH:MM:SS format, or null if it has not been published
    @jsondata:Name {value: "published_at"}
    string publishedAt?;
    # the immutable unique code name of the template
    string slug?;
    # the full HTML code of the template, with mc:edit attributes marking the editable elements that are available as published, if it has been published
    @jsondata:Name {value: "publish_code"}
    string publishCode?;
};

# the information saved about the new template
public type InlineResponse20060 record {
    # the full HTML code of the template, with mc:edit attributes marking the editable elements - draft version
    string code?;
    # the default sender address for the template, if provided - draft version
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # the subject line of the template, if provided - draft version
    string subject?;
    # the default sender address for the template, if provided
    @jsondata:Name {value: "publish_from_email"}
    string publishFromEmail?;
    # the date and time the template was first created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the default sender from name for the template, if provided - draft version
    @jsondata:Name {value: "from_name"}
    string fromName?;
    # indicates if the template is malformed or corrupt
    @jsondata:Name {value: "is_broken_template"}
    boolean isBrokenTemplate?;
    # the list of labels applied to the template
    string[] labels?;
    # the same as the template name - kept as a separate field for backwards compatibility
    @jsondata:Name {value: "publish_name"}
    string publishName?;
    # the subject line of the template, if provided
    @jsondata:Name {value: "publish_subject"}
    string publishSubject?;
    # the date and time the template was last modified as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "updated_at"}
    string updatedAt?;
    # the default text part of messages sent with the template, if provided
    @jsondata:Name {value: "publish_text"}
    string publishText?;
    # the name of the template
    string name?;
    # the default text part of messages sent with the template, if provided - draft version
    string text?;
    # the default sender from name for the template, if provided
    @jsondata:Name {value: "publish_from_name"}
    string publishFromName?;
    # the date and time the template was last published as a UTC string in YYYY-MM-DD HH:MM:SS format, or null if it has not been published
    @jsondata:Name {value: "published_at"}
    string publishedAt?;
    # the immutable unique code name of the template
    string slug?;
    # the full HTML code of the template, with mc:edit attributes marking the editable elements that are available as published, if it has been published
    @jsondata:Name {value: "publish_code"}
    string publishCode?;
};

# the template that was published
public type InlineResponse20063 record {
    # the full HTML code of the template, with mc:edit attributes marking the editable elements - draft version
    string code?;
    # the default sender address for the template, if provided - draft version
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # the subject line of the template, if provided - draft version
    string subject?;
    # the default sender address for the template, if provided
    @jsondata:Name {value: "publish_from_email"}
    string publishFromEmail?;
    # the date and time the template was first created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the default sender from name for the template, if provided - draft version
    @jsondata:Name {value: "from_name"}
    string fromName?;
    # indicates if the template is malformed or corrupt
    @jsondata:Name {value: "is_broken_template"}
    boolean isBrokenTemplate?;
    # the list of labels applied to the template
    string[] labels?;
    # the same as the template name - kept as a separate field for backwards compatibility
    @jsondata:Name {value: "publish_name"}
    string publishName?;
    # the subject line of the template, if provided
    @jsondata:Name {value: "publish_subject"}
    string publishSubject?;
    # the date and time the template was last modified as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "updated_at"}
    string updatedAt?;
    # the default text part of messages sent with the template, if provided
    @jsondata:Name {value: "publish_text"}
    string publishText?;
    # the name of the template
    string name?;
    # the default text part of messages sent with the template, if provided - draft version
    string text?;
    # the default sender from name for the template, if provided
    @jsondata:Name {value: "publish_from_name"}
    string publishFromName?;
    # the date and time the template was last published as a UTC string in YYYY-MM-DD HH:MM:SS format, or null if it has not been published
    @jsondata:Name {value: "published_at"}
    string publishedAt?;
    # the immutable unique code name of the template
    string slug?;
    # the full HTML code of the template, with mc:edit attributes marking the editable elements that are available as published, if it has been published
    @jsondata:Name {value: "publish_code"}
    string publishCode?;
};

# the template that was updated
public type InlineResponse20062 record {
    # the full HTML code of the template, with mc:edit attributes marking the editable elements - draft version
    string code?;
    # the default sender address for the template, if provided - draft version
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # the subject line of the template, if provided - draft version
    string subject?;
    # the default sender address for the template, if provided
    @jsondata:Name {value: "publish_from_email"}
    string publishFromEmail?;
    # the date and time the template was first created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the default sender from name for the template, if provided - draft version
    @jsondata:Name {value: "from_name"}
    string fromName?;
    # indicates if the template is malformed or corrupt
    @jsondata:Name {value: "is_broken_template"}
    boolean isBrokenTemplate?;
    # the list of labels applied to the template
    string[] labels?;
    # the same as the template name - kept as a separate field for backwards compatibility
    @jsondata:Name {value: "publish_name"}
    string publishName?;
    # the subject line of the template, if provided
    @jsondata:Name {value: "publish_subject"}
    string publishSubject?;
    # the date and time the template was last modified as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "updated_at"}
    string updatedAt?;
    # the default text part of messages sent with the template, if provided
    @jsondata:Name {value: "publish_text"}
    string publishText?;
    # the name of the template
    string name?;
    # the default text part of messages sent with the template, if provided - draft version
    string text?;
    # the default sender from name for the template, if provided
    @jsondata:Name {value: "publish_from_name"}
    string publishFromName?;
    # the date and time the template was last published as a UTC string in YYYY-MM-DD HH:MM:SS format, or null if it has not been published
    @jsondata:Name {value: "published_at"}
    string publishedAt?;
    # the immutable unique code name of the template
    string slug?;
    # the full HTML code of the template, with mc:edit attributes marking the editable elements that are available as published, if it has been published
    @jsondata:Name {value: "publish_code"}
    string publishCode?;
};

public type UrlsSearchBody record {
    # a search query
    string q;
    # a valid api key
    string 'key;
};

# the information on each template in the account
public type InlineResponse20065 record {
    # the full HTML code of the template, with mc:edit attributes marking the editable elements - draft version
    string code?;
    # the default sender address for the template, if provided - draft version
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # the subject line of the template, if provided - draft version
    string subject?;
    # the default sender address for the template, if provided
    @jsondata:Name {value: "publish_from_email"}
    string publishFromEmail?;
    # the date and time the template was first created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the default sender from name for the template, if provided - draft version
    @jsondata:Name {value: "from_name"}
    string fromName?;
    # indicates if the template is malformed or corrupt
    @jsondata:Name {value: "is_broken_template"}
    boolean isBrokenTemplate?;
    # the list of labels applied to the template
    string[] labels?;
    # the same as the template name - kept as a separate field for backwards compatibility
    @jsondata:Name {value: "publish_name"}
    string publishName?;
    # the subject line of the template, if provided
    @jsondata:Name {value: "publish_subject"}
    string publishSubject?;
    # the date and time the template was last modified as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "updated_at"}
    string updatedAt?;
    # the default text part of messages sent with the template, if provided
    @jsondata:Name {value: "publish_text"}
    string publishText?;
    # the name of the template
    string name?;
    # the default text part of messages sent with the template, if provided - draft version
    string text?;
    # the default sender from name for the template, if provided
    @jsondata:Name {value: "publish_from_name"}
    string publishFromName?;
    # the date and time the template was last published as a UTC string in YYYY-MM-DD HH:MM:SS format, or null if it has not been published
    @jsondata:Name {value: "published_at"}
    string publishedAt?;
    # the immutable unique code name of the template
    string slug?;
    # the full HTML code of the template, with mc:edit attributes marking the editable elements that are available as published, if it has been published
    @jsondata:Name {value: "publish_code"}
    string publishCode?;
};

# the template that was deleted
public type InlineResponse20064 record {
    # the full HTML code of the template, with mc:edit attributes marking the editable elements - draft version
    string code?;
    # the default sender address for the template, if provided - draft version
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # the subject line of the template, if provided - draft version
    string subject?;
    # the default sender address for the template, if provided
    @jsondata:Name {value: "publish_from_email"}
    string publishFromEmail?;
    # the date and time the template was first created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the default sender from name for the template, if provided - draft version
    @jsondata:Name {value: "from_name"}
    string fromName?;
    # indicates if the template is malformed or corrupt
    @jsondata:Name {value: "is_broken_template"}
    boolean isBrokenTemplate?;
    # the list of labels applied to the template
    string[] labels?;
    # the same as the template name - kept as a separate field for backwards compatibility
    @jsondata:Name {value: "publish_name"}
    string publishName?;
    # the subject line of the template, if provided
    @jsondata:Name {value: "publish_subject"}
    string publishSubject?;
    # the date and time the template was last modified as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "updated_at"}
    string updatedAt?;
    # the default text part of messages sent with the template, if provided
    @jsondata:Name {value: "publish_text"}
    string publishText?;
    # the name of the template
    string name?;
    # the default text part of messages sent with the template, if provided - draft version
    string text?;
    # the default sender from name for the template, if provided
    @jsondata:Name {value: "publish_from_name"}
    string publishFromName?;
    # the date and time the template was last published as a UTC string in YYYY-MM-DD HH:MM:SS format, or null if it has not been published
    @jsondata:Name {value: "published_at"}
    string publishedAt?;
    # the immutable unique code name of the template
    string slug?;
    # the full HTML code of the template, with mc:edit attributes marking the editable elements that are available as published, if it has been published
    @jsondata:Name {value: "publish_code"}
    string publishCode?;
};

# the individual URL stats
public type InlineResponse20067 record {
    # the number of unique emails that have generated clicks for this URL
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of times the URL has been clicked from a tracked email
    int clicks?;
    # the number of emails that contained the URL
    int sent?;
    # the URL to be tracked
    string url?;
};

public type IpsSetPoolBody record {
    # a dedicated ip address
    string ip;
    # the name of the new pool to add the dedicated ip to
    string pool;
    # whether to create the pool if it does not exist; if false and the pool does not exist, an Unknown_Pool will be thrown
    @jsondata:Name {value: "create_pool"}
    boolean createPool?;
    # a valid api key
    string 'key;
};

# the result of rendering the given template with the content and merge field values injected
public type InlineResponse20066 record {
    # the rendered HTML as a string
    string html?;
};

public type MessagesInfoBody record {
    # the unique id of the message to get - passed as the "_id" field in webhooks, send calls, or search calls
    string id;
    # a valid api key
    string 'key;
};

# the information for a single hour
public type InlineResponse20069 record {
    # the number of unique clicks generated for emails sent with this URL during the hour
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of times the URL was clicked during the hour
    int clicks?;
    # the hour as a UTC date string in YYYY-MM-DD HH:MM:SS format
    string time?;
    # the number of emails that were sent with the URL during the hour
    int sent?;
};

# the URL matching the query
public type InlineResponse20068 record {
    # the number of unique emails that have generated clicks for this URL
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of times the URL has been clicked from a tracked email
    int clicks?;
    # the number of emails that contained the URL
    int sent?;
    # the URL to be tracked
    string url?;
};

public type MessagesRescheduleBody record {
    # the new UTC timestamp when the message should sent. Mandrill can't time travel, so if you specify a time in past the message will be sent immediately; for future dates, you're limited to one year from the date of scheduling
    @jsondata:Name {value: "send_at"}
    string sendAt;
    # a scheduled email id, as returned by any of the messages/send calls or messages/list-scheduled
    string id;
    # a valid api key
    string 'key;
};

public type IpsPoolInfoBody record {
    # a pool name
    string pool;
    # a valid api key
    string 'key;
};

public type TagsDeleteBody record {
    # a tag name
    string tag;
    # a valid api key
    string 'key;
};

public type SubaccountsAddBody record {
    # optional extra text to associate with the subaccount
    string notes?;
    # an optional manual hourly quota for the subaccount. If not specified, Mandrill will manage this based on reputation
    @jsondata:Name {value: "custom_quota"}
    int customQuota?;
    # an optional display name to further identify the subaccount
    @constraint:String {maxLength: 1024}
    string name?;
    # a unique identifier for the subaccount to be used in sending calls
    @constraint:String {maxLength: 255}
    string id;
    # a valid api key
    string 'key;
};

# a single embedded image
public type MessagessendMessageImages record {
    # the Content ID of the image - use <img src="cid:THIS_VALUE"> to reference the image in your HTML content
    string name?;
    # the MIME type of the image - must start with "image/"
    string 'type?;
    # the content of the image as a base64-encoded string
    string content?;
};

# details about the domain's Legacy DKIM record
public type SendersdomainsDkim record {
    # whether the domain's Legacy DKIM record is valid for use with Mandrill
    boolean valid?;
    # when the domain's Legacy DKIM record will be considered valid for use with Mandrill as a UTC string in YYYY-MM-DD HH:MM:SS format. If set, this indicates that the record is valid now, but was previously invalid, and Mandrill will wait until the record's TTL elapses to start using it
    @jsondata:Name {value: "valid_after"}
    string validAfter?;
    # an error describing the Legacy DKIM record, or null if the record is correct
    string 'error?;
};

# the individual tracking domain
public type InlineResponse20070 record {
    # when the domain's DNS settings were last tested as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "last_tested_at"}
    string lastTestedAt?;
    # whether this domain can be used as a tracking domain for email
    @jsondata:Name {value: "valid_tracking"}
    boolean validTracking?;
    # the tracking domain name
    string domain?;
    # details about the domain's CNAME record
    UrlstrackingDomainsCname cname?;
    # the date and time that the tracking domain was added as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
};

# the user information including username, key, reputation, quota, and historical sending stats
public type InlineResponse20072 record {
    # the maximum number of emails Mandrill will deliver for this user each hour. Any emails beyond that will be accepted and queued for later delivery. Users with higher reputations will have higher hourly quotas
    @jsondata:Name {value: "hourly_quota"}
    int hourlyQuota?;
    # the number of emails that are queued for delivery due to exceeding your monthly or hourly quotas
    int backlog?;
    # an aggregate summary of the account's sending stats
    InlineResponse20072Stats stats?;
    # the date and time that the user's Mandrill account was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the reputation of the user on a scale from 0 to 100, with 75 generally being a "good" reputation
    int reputation?;
    # the username of the user (used for SMTP authentication)
    string username?;
    # a unique, permanent identifier for this user
    @jsondata:Name {value: "public_id"}
    string publicId?;
};

public type TemplatesInfoBody record {
    # the immutable name of an existing template
    string name;
    # a valid api key
    string 'key;
};

# information about the tracking domain
public type InlineResponse20071 record {
    # when the domain's DNS settings were last tested as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "last_tested_at"}
    string lastTestedAt?;
    # whether this domain can be used as a tracking domain for email
    @jsondata:Name {value: "valid_tracking"}
    boolean validTracking?;
    # the tracking domain name
    string domain?;
    # details about the domain's CNAME record
    UrlstrackingDomainsCname cname?;
    # the date and time that the tracking domain was added as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
};

public type SubaccountsDeleteBody record {
    # the unique identifier of the subaccount to delete
    string id;
    # a valid api key
    string 'key;
};

# the individual webhook info
public type InlineResponse20074 record {
    # the date and time that the webhook last successfully received events as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "last_sent_at"}
    string lastSentAt?;
    # the total number of events that have ever been sent to this webhook
    @jsondata:Name {value: "events_sent"}
    int eventsSent?;
    # a description of the webhook
    string description?;
    # the date and time that the webhook was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # a unique integer indentifier for the webhook
    int id?;
    # the key used to requests for this webhook
    @jsondata:Name {value: "auth_key"}
    string authKey?;
    # the number of event batches that have ever been sent to this webhook
    @jsondata:Name {value: "batches_sent"}
    int batchesSent?;
    # if we've ever gotten an error trying to post to this webhook, the last error that we've seen
    @jsondata:Name {value: "last_error"}
    string lastError?;
    # The URL that the event data will be posted to
    string url?;
    # The message events that will be posted to the hook
    ("send"|"hard_bounce"|"soft_bounce"|"open"|"click"|"spam"|"unsub"|"reject")[] events?;
};

# a struct with one key "PING" with a static value "PONG!"
public type InlineResponse20073 record {
    # a simple pong response
    @jsondata:Name {value: "PING"}
    string pING?;
};

# stats with this tag in the last 30 days
public type InlineResponse20059StatsLast30Days record {
    # the number of emails rejected for sending this sender in the last 30 days
    int rejects?;
    # the number of emails hard bounced with this tag in the last 30 days
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent with this tag in the last 30 days
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes with this tag in the last 30 days
    int unsubs?;
    # the number of spam complaints with this tag in the last 30 days
    int complaints?;
    # the number of times emails have been opened with this tag in the last 30 days
    int opens?;
    # the number of URLs that have been clicked with this tag in the last 30 days
    int clicks?;
    # the number of emails soft bounced with this tag in the last 30 days
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent with this tag in the last 30 days
    int sent?;
    # the number of unique opens for emails sent with this tag in the last 30 days
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# the information about the webhook
public type InlineResponse20076 record {
    # the date and time that the webhook last successfully received events as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "last_sent_at"}
    string lastSentAt?;
    # the total number of events that have ever been sent to this webhook
    @jsondata:Name {value: "events_sent"}
    int eventsSent?;
    # a description of the webhook
    string description?;
    # the date and time that the webhook was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # a unique integer indentifier for the webhook
    int id?;
    # the key used to requests for this webhook
    @jsondata:Name {value: "auth_key"}
    string authKey?;
    # the number of event batches that have ever been sent to this webhook
    @jsondata:Name {value: "batches_sent"}
    int batchesSent?;
    # if we've ever gotten an error trying to post to this webhook, the last error that we've seen
    @jsondata:Name {value: "last_error"}
    string lastError?;
    # The URL that the event data will be posted to
    string url?;
    # The message events that will be posted to the hook
    ("send"|"hard_bounce"|"soft_bounce"|"open"|"click"|"spam"|"unsub"|"reject")[] events?;
};

# the information saved about the new webhook
public type InlineResponse20075 record {
    # the date and time that the webhook last successfully received events as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "last_sent_at"}
    string lastSentAt?;
    # the total number of events that have ever been sent to this webhook
    @jsondata:Name {value: "events_sent"}
    int eventsSent?;
    # a description of the webhook
    string description?;
    # the date and time that the webhook was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # a unique integer indentifier for the webhook
    int id?;
    # the key used to requests for this webhook
    @jsondata:Name {value: "auth_key"}
    string authKey?;
    # the number of event batches that have ever been sent to this webhook
    @jsondata:Name {value: "batches_sent"}
    int batchesSent?;
    # if we've ever gotten an error trying to post to this webhook, the last error that we've seen
    @jsondata:Name {value: "last_error"}
    string lastError?;
    # The URL that the event data will be posted to
    string url?;
    # The message events that will be posted to the hook
    ("send"|"hard_bounce"|"soft_bounce"|"open"|"click"|"spam"|"unsub"|"reject")[] events?;
};

# the information for the deleted webhook
public type InlineResponse20078 record {
    # the date and time that the webhook last successfully received events as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "last_sent_at"}
    string lastSentAt?;
    # the total number of events that have ever been sent to this webhook
    @jsondata:Name {value: "events_sent"}
    int eventsSent?;
    # a description of the webhook
    string description?;
    # the date and time that the webhook was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # a unique integer indentifier for the webhook
    int id?;
    # the key used to requests for this webhook
    @jsondata:Name {value: "auth_key"}
    string authKey?;
    # the number of event batches that have ever been sent to this webhook
    @jsondata:Name {value: "batches_sent"}
    int batchesSent?;
    # if we've ever gotten an error trying to post to this webhook, the last error that we've seen
    @jsondata:Name {value: "last_error"}
    string lastError?;
    # The URL that the event data will be posted to
    string url?;
    # The message events that will be posted to the hook
    ("send"|"hard_bounce"|"soft_bounce"|"open"|"click"|"spam"|"unsub"|"reject")[] events?;
};

# the information for the updated webhook
public type InlineResponse20077 record {
    # the date and time that the webhook last successfully received events as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "last_sent_at"}
    string lastSentAt?;
    # the total number of events that have ever been sent to this webhook
    @jsondata:Name {value: "events_sent"}
    int eventsSent?;
    # a description of the webhook
    string description?;
    # the date and time that the webhook was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # a unique integer indentifier for the webhook
    int id?;
    # the key used to requests for this webhook
    @jsondata:Name {value: "auth_key"}
    string authKey?;
    # the number of event batches that have ever been sent to this webhook
    @jsondata:Name {value: "batches_sent"}
    int batchesSent?;
    # if we've ever gotten an error trying to post to this webhook, the last error that we've seen
    @jsondata:Name {value: "last_error"}
    string lastError?;
    # The URL that the event data will be posted to
    string url?;
    # The message events that will be posted to the hook
    ("send"|"hard_bounce"|"soft_bounce"|"open"|"click"|"spam"|"unsub"|"reject")[] events?;
};

# the information on a single recipient
public type InlineResponse20034To record {
    # the alias of the recipient (if any)
    string name?;
    # the email address of the recipient
    string email?;
};

# the information on the message to send
public type MessagessendMessage record {
    # optional string indicating the value to set for the utm_campaign tracking parameter. If this isn't provided the email's from address will be used instead
    @jsondata:Name {value: "google_analytics_campaign"}
    string googleAnalyticsCampaign?;
    # metadata an associative array of user metadata. Mandrill will store this metadata and make it available for retrieval. In addition, you can select up to 10 metadata fields to index and make searchable using the Mandrill search api
    MessagessendMessageMetadata metadata?;
    # the sender email address
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # an array of supported attachments to add to the message
    MessagessendMessageAttachments[] attachments?;
    # the message subject
    string subject?;
    # Per-recipient metadata that will override the global values specified in the metadata parameter
    @jsondata:Name {value: "recipient_metadata"}
    MessagessendMessageRecipientMetadata[] recipientMetadata?;
    # whether or not to turn on open tracking for the message
    @jsondata:Name {value: "track_opens"}
    boolean trackOpens?;
    # whether or not to expose all recipients in to "To" header for each email
    @jsondata:Name {value: "preserve_recipients"}
    boolean preserveRecipients?;
    # optional from name to be used
    @jsondata:Name {value: "from_name"}
    string fromName?;
    # the merge tag language to use when evaluating merge tags, either mailchimp or handlebars
    @jsondata:Name {value: "merge_language"}
    "mailchimp"|"handlebars" mergeLanguage?;
    # an array of strings indicating for which any matching URLs will automatically have Google Analytics parameters appended to their query string automatically
    @jsondata:Name {value: "google_analytics_domains"}
    string[] googleAnalyticsDomains?;
    # a custom domain to use for the messages's return-path
    @jsondata:Name {value: "return_path_domain"}
    string returnPathDomain?;
    # whether to evaluate merge tags in the message. Will automatically be set to true if either merge_vars or global_merge_vars are provided
    boolean merge?;
    # the full HTML content to be sent
    string html?;
    # optional full text content to be sent
    string text?;
    # whether or not to turn on click tracking for the message
    @jsondata:Name {value: "track_clicks"}
    boolean trackClicks?;
    # whether or not to strip the query string from URLs when aggregating tracked URL data
    @jsondata:Name {value: "url_strip_qs"}
    boolean urlStripQs?;
    # a custom domain to use for SPF/DKIM signing instead of mandrill (for "via" or "on behalf of" in email clients)
    @jsondata:Name {value: "signing_domain"}
    string signingDomain?;
    # set to false to remove content logging for sensitive emails
    @jsondata:Name {value: "view_content_link"}
    boolean viewContentLink?;
    # optional extra headers to add to the message (most headers are allowed)
    record {} headers?;
    # an array of embedded images to add to the message
    MessagessendMessageImages[] images?;
    # an optional address to receive an exact copy of each recipient's email
    @jsondata:Name {value: "bcc_address"}
    string bccAddress?;
    # the unique id of a subaccount for this message - must already exist or will fail with an error
    string subaccount?;
    # per-recipient merge variables, which override global merge variables with the same name
    @jsondata:Name {value: "merge_vars"}
    MessagessendMessageMergeVars[] mergeVars?;
    # a custom domain to use for tracking opens and clicks instead of mandrillapp.com
    @jsondata:Name {value: "tracking_domain"}
    string trackingDomain?;
    # an array of string to tag the message with. Stats are accumulated using tags, though we only store the first 100 we see, so this should not be unique or change frequently. Tags should be 50 characters or less. Any tags starting with an underscore are reserved for internal use and will cause errors
    string[] tags?;
    # whether or not this message is important, and should be delivered ahead of non-important messages
    boolean important?;
    # global merge variables to use for all recipients. You can override these per recipient
    @jsondata:Name {value: "global_merge_vars"}
    MessagessendMessageGlobalMergeVars[] globalMergeVars?;
    # whether or not to automatically generate a text part for messages that are not given text
    @jsondata:Name {value: "auto_text"}
    boolean autoText?;
    # whether or not to automatically inline all CSS styles provided in the message HTML - only for HTML documents less than 256KB in size
    @jsondata:Name {value: "inline_css"}
    boolean inlineCss?;
    # an array of recipient information
    MessagessendMessageTo[] to?;
    # whether or not to automatically generate an HTML part for messages that are not given HTML
    @jsondata:Name {value: "auto_html"}
    boolean autoHtml?;
};

public type ExportsListBody record {
    # a valid api key
    string 'key;
};

public type IpsSetCustomDnsBody record {
    # a dedicated ip address
    string ip;
    # a domain name to set as the dedicated IP's custom dns name
    string domain;
    # a valid api key
    string 'key;
};

public type IpsCreatePoolBody record {
    # the name of a pool to create
    string pool;
    # a valid api key
    string 'key;
};

public type IpsDeleteBody record {
    # the dedicated ip to remove from your account
    string ip;
    # a valid api key
    string 'key;
};

# stats for this sender in the last 30 days
public type InlineResponse20048StatsLast30Days record {
    # the number of emails rejected for sending this sender in the last 30 days
    int rejects?;
    # the number of emails hard bounced for this sender in the last 30 days
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent for this sender in the last 30 days
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes for this sender in the last 30 days
    int unsubs?;
    # the number of spam complaints for this sender in the last 30 days
    int complaints?;
    # the number of times emails have been opened for this sender in the last 30 days
    int opens?;
    # the number of URLs that have been clicked for this sender in the last 30 days
    int clicks?;
    # the number of emails soft bounced for this sender in the last 30 days
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent for this sender in the last 30 days
    int sent?;
    # the number of unique opens for emails sent for this sender in the last 30 days
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# details about the domain's DMARC record
public type SendersdomainsDmarc record {
    # whether the domain's DMARC record is valid for use with Mandrill
    boolean valid?;
    # an error describing the DMARC record, or null if the record is correct
    string 'error?;
};

public type AllowlistsAddBody record {
    # an optional description of why the email was added to the allowlist
    @constraint:String {maxLength: 255}
    string comment?;
    # a valid api key
    string 'key;
    # an email address to add to the allowlist
    string email;
};

# stats for this sender in the last 90 days
public type InlineResponse20048StatsLast90Days record {
    # the number of emails rejected for sending this sender in the last 90 days
    int rejects?;
    # the number of emails hard bounced for this sender in the last 90 days
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent for this sender in the last 90 days
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes for this sender in the last 90 days
    int unsubs?;
    # the number of spam complaints for this sender in the last 90 days
    int complaints?;
    # the number of times emails have been opened for this sender in the last 90 days
    int opens?;
    # the number of URLs that have been clicked for this sender in the last 90 days
    int clicks?;
    # the number of emails soft bounced for this sender in the last 90 days
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent for this sender in the last 90 days
    int sent?;
    # the number of unique opens for emails sent for this sender in the last 90 days
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# stats with this tag so far today
public type InlineResponse20059StatsToday record {
    # the number of emails rejected for sending this sender so far today
    int rejects?;
    # the number of emails hard bounced with this tag so far today
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent with this tag so far today
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes with this tag so far today
    int unsubs?;
    # the number of spam complaints with this tag so far today
    int complaints?;
    # the number of times emails have been opened with this tag so far today
    int opens?;
    # the number of URLs that have been clicked with this tag so far today
    int clicks?;
    # the number of emails soft bounced with this tag so far today
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent with this tag so far today
    int sent?;
    # the number of unique opens for emails sent with this tag so far today
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

public type MessagesSendBody record {
    # enable a background sending mode that is optimized for bulk sending. In async mode, messages/send will immediately return a status of "queued" for every recipient. To handle rejections when sending in async mode, set up a webhook for the 'reject' event. Defaults to false for messages with no more than 10 recipients; messages with more than 10 recipients are always sent asynchronously, regardless of the value of async
    boolean async?;
    # the name of the dedicated ip pool that should be used to send the message. If you do not have any dedicated IPs, this parameter has no effect. If you specify a pool that does not exist, your default pool will be used instead
    @jsondata:Name {value: "ip_pool"}
    string ipPool?;
    # when this message should be sent as a UTC timestamp in YYYY-MM-DD HH:MM:SS format. If you specify a time in the past, the message will be sent immediately; for future dates, you're limited to one year from the date of scheduling
    @jsondata:Name {value: "send_at"}
    string sendAt?;
    # the information on the message to send
    MessagessendMessage message;
    # a valid api key
    string 'key;
};

@constraint:String {maxLength: 100}
public type TemplatesAddBodyLabelsItemsString string;

public type MessagesSearchBody record {
    # search terms to find matching messages
    string query?;
    # the maximum number of results to return, defaults to 100, 1000 is the maximum
    @constraint:Int {minValue: 100, maxValue: 1000}
    int 'limit?;
    # end date
    @jsondata:Name {value: "date_to"}
    string dateTo?;
    # an array of API keys to narrow the search to, will return messages sent by ANY of the keys
    @jsondata:Name {value: "api_keys"}
    string[] apiKeys?;
    # an array of sender addresses to narrow the search to, will return messages sent by ANY of the senders
    string[] senders?;
    # a valid api key
    string 'key;
    # start date
    @jsondata:Name {value: "date_from"}
    string dateFrom?;
    # an array of tag names to narrow the search to, will return messages that contain ANY of the tags
    string[] tags?;
};

# a single recipient's information
public type MessagessendMessageTo record {
    # the optional display name to use for the recipient
    string name?;
    # the header type to use for the recipient, defaults to "to" if not provided
    "to"|"cc"|"bcc" 'type?;
    # the email address of the recipient
    string email;
};

# the message recipient's information
public type InlineResponse20033To record {
    # the alias of the recipient (if any)
    string name?;
    # the email address of the recipient
    string email?;
};

# a description of the provisioning request that was created
public type InlineResponse20019 record {
    # the date and time that the request was created as a UTC timestamp in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "requested_at"}
    string requestedAt?;
};

# details about the domain's CNAME record
public type UrlstrackingDomainsCname record {
    # whether the domain's CNAME record is valid for use with Mandrill
    boolean valid?;
    # when the domain's CNAME record will be considered valid for use with Mandrill as a UTC string in YYYY-MM-DD HH:MM:SS format. If set, this indicates that the record is valid now, but was previously invalid, and Mandrill will wait until the record's TTL elapses to start using it
    @jsondata:Name {value: "valid_after"}
    string validAfter?;
    # an error describing the CNAME record, or null if the record is correct
    string 'error?;
};

# information about an individual attachment
public type InlineResponse20034Attachments record {
    # if this is set to true, the attachment is not pure-text, and the content will be base64 encoded
    boolean binary?;
    # the file name of the attachment
    string name?;
    # the MIME type of the attachment
    string 'type?;
    # the content of the attachment as a base64 encoded string
    string content?;
};

public type MetadataUpdateBody record {
    # the unique identifier of the metadata field to update
    string name;
    # Mustache template to control how the metadata is rendered in your activity log
    @jsondata:Name {value: "view_template"}
    string viewTemplate;
    # a valid api key
    string 'key;
};

# stats with this tag in the last 7 days
public type InlineResponse20059StatsLast7Days record {
    # the number of emails rejected for sending this sender in the last 7 days
    int rejects?;
    # the number of emails hard bounced with this tag in the last 7 days
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent with this tag in the last 7 days
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes with this tag in the last 7 days
    int unsubs?;
    # the number of spam complaints with this tag in the last 7 days
    int complaints?;
    # the number of times emails have been opened with this tag in the last 7 days
    int opens?;
    # the number of URLs that have been clicked with this tag in the last 7 days
    int clicks?;
    # the number of emails soft bounced with this tag in the last 7 days
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent with this tag in the last 7 days
    int sent?;
    # the number of unique opens for emails sent with this tag in the last 7 days
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# the other information on the message to send - same as /messages/send, but without the html content
public type MessagessendTemplateMessage record {
    # optional string indicating the value to set for the utm_campaign tracking parameter. If this isn't provided the email's from address will be used instead
    @jsondata:Name {value: "google_analytics_campaign"}
    string googleAnalyticsCampaign?;
    # metadata an associative array of user metadata. Mandrill will store this metadata and make it available for retrieval. In addition, you can select up to 10 metadata fields to index and make searchable using the Mandrill search api
    MessagessendMessageMetadata metadata?;
    # the sender email address
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # an array of supported attachments to add to the message
    MessagessendMessageAttachments[] attachments?;
    # the message subject
    string subject?;
    # Per-recipient metadata that will override the global values specified in the metadata parameter
    @jsondata:Name {value: "recipient_metadata"}
    MessagessendMessageRecipientMetadata[] recipientMetadata?;
    # whether or not to turn on open tracking for the message
    @jsondata:Name {value: "track_opens"}
    boolean trackOpens?;
    # whether or not to expose all recipients in to "To" header for each email
    @jsondata:Name {value: "preserve_recipients"}
    boolean preserveRecipients?;
    # optional from name to be used
    @jsondata:Name {value: "from_name"}
    string fromName?;
    # the merge tag language to use when evaluating merge tags, either mailchimp or handlebars
    @jsondata:Name {value: "merge_language"}
    "mailchimp"|"handlebars" mergeLanguage?;
    # an array of strings indicating for which any matching URLs will automatically have Google Analytics parameters appended to their query string automatically
    @jsondata:Name {value: "google_analytics_domains"}
    string[] googleAnalyticsDomains?;
    # a custom domain to use for the messages's return-path
    @jsondata:Name {value: "return_path_domain"}
    string returnPathDomain?;
    # whether to evaluate merge tags in the message. Will automatically be set to true if either merge_vars or global_merge_vars are provided
    boolean merge?;
    # optional full HTML content to be sent if not in template
    string html?;
    # optional full text content to be sent
    string text?;
    # whether or not to turn on click tracking for the message
    @jsondata:Name {value: "track_clicks"}
    boolean trackClicks?;
    # whether or not to strip the query string from URLs when aggregating tracked URL data
    @jsondata:Name {value: "url_strip_qs"}
    boolean urlStripQs?;
    # a custom domain to use for SPF/DKIM signing instead of mandrill (for "via" or "on behalf of" in email clients)
    @jsondata:Name {value: "signing_domain"}
    string signingDomain?;
    # set to false to remove content logging for sensitive emails
    @jsondata:Name {value: "view_content_link"}
    boolean viewContentLink?;
    # optional extra headers to add to the message (most headers are allowed)
    record {} headers?;
    # an array of embedded images to add to the message
    MessagessendMessageImages[] images?;
    # an optional address to receive an exact copy of each recipient's email
    @jsondata:Name {value: "bcc_address"}
    string bccAddress?;
    # the unique id of a subaccount for this message - must already exist or will fail with an error
    string subaccount?;
    # per-recipient merge variables, which override global merge variables with the same name
    @jsondata:Name {value: "merge_vars"}
    MessagessendMessageMergeVars[] mergeVars?;
    # a custom domain to use for tracking opens and clicks instead of mandrillapp.com
    @jsondata:Name {value: "tracking_domain"}
    string trackingDomain?;
    # an array of string to tag the message with. Stats are accumulated using tags, though we only store the first 100 we see, so this should not be unique or change frequently. Tags should be 50 characters or less. Any tags starting with an underscore are reserved for internal use and will cause errors
    string[] tags?;
    # whether or not this message is important, and should be delivered ahead of non-important messages
    boolean important?;
    # global merge variables to use for all recipients. You can override these per recipient
    @jsondata:Name {value: "global_merge_vars"}
    MessagessendMessageGlobalMergeVars[] globalMergeVars?;
    # whether or not to automatically generate a text part for messages that are not given text
    @jsondata:Name {value: "auto_text"}
    boolean autoText?;
    # whether or not to automatically inline all CSS styles provided in the message HTML - only for HTML documents less than 256KB in size
    @jsondata:Name {value: "inline_css"}
    boolean inlineCss?;
    # an array of recipient information
    MessagessendMessageTo[] to?;
    # whether or not to automatically generate an HTML part for messages that are not given HTML
    @jsondata:Name {value: "auto_html"}
    boolean autoHtml?;
};

# Information about the updated state of the dedicated IP
public type InlineResponse20021 record {
    @jsondata:Name {value: "custom_dns"}
    IpslistCustomDns customDns?;
    # the ip address
    string ip?;
    # the domain name (reverse dns) of this dedicated IP
    string domain?;
    # the name of the pool that this dedicated IP belongs to
    string pool?;
    # the date and time that the dedicated IP was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # information about the ip's warmup status
    IpslistWarmup warmup?;
};

# Information about the dedicated IP
public type InlineResponse20020 record {
    @jsondata:Name {value: "custom_dns"}
    IpslistCustomDns customDns?;
    # the ip address
    string ip?;
    # the domain name (reverse dns) of this dedicated IP
    string domain?;
    # the name of the pool that this dedicated IP belongs to
    string pool?;
    # the date and time that the dedicated IP was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # information about the ip's warmup status
    IpslistWarmup warmup?;
};

# information about each dedicated IP pool
public type InlineResponse20023 record {
    # this pool's name
    string name?;
    # the date and time that this pool was created as a UTC timestamp in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the dedicated IPs in this pool
    IpslistPoolsIps[] ips?;
};

# a description of the ip that was removed from your account
public type InlineResponse20022 record {
    # a boolean indicating whether the ip was successfully deleted
    string deleted?;
    # the ip address
    string ip?;
};

# information about the status of the pool that was deleted
public type InlineResponse20025 record {
    # whether the pool was deleted
    boolean deleted?;
    # the name of the pool
    string pool?;
};

public type SubaccountsInfoBody record {
    # the unique identifier of the subaccount to query
    string id;
    # a valid api key
    string 'key;
};

# Information about the dedicated ip pool
public type InlineResponse20024 record {
    # this pool's name
    string name?;
    # the date and time that this pool was created as a UTC timestamp in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the dedicated IPs in this pool
    IpslistPoolsIps[] ips?;
};

# information about the dedicated IP's new configuration
public type InlineResponse20027 record {
    @jsondata:Name {value: "custom_dns"}
    IpslistCustomDns customDns?;
    # the ip address
    string ip?;
    # the domain name (reverse dns) of this dedicated IP
    string domain?;
    # the name of the pool that this dedicated IP belongs to
    string pool?;
    # the date and time that the dedicated IP was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # information about the ip's warmup status
    IpslistWarmup warmup?;
};

# information about the dedicated IP's new configuration
public type InlineResponse20026 record {
    # whether the domain name has a correctly-configured A record pointing to the ip address
    string valid?;
    # if valid is false, this will contain details about why the domain's A record is incorrect
    string 'error?;
};

# the sending results for a single recipient
public type InlineResponse20029 record {
    # the reason for the rejection if the recipient status is "rejected"
    @jsondata:Name {value: "reject_reason"}
    "hard-bounce"|"soft-bounce"|"spam"|"unsub"|"custom"|"invalid-sender"|"invalid"|"test-mode-limit"|"unsigned"|"rule" rejectReason?;
    # the message's unique id
    @jsondata:Name {value: "_id"}
    string id?;
    # the reason for the email being queued if the response status is "queued"
    @jsondata:Name {value: "queued_reason"}
    "attachments"|"multiple-recipients"|"free-trial-sends-exhausted"|"hourly-quota-exhausted"|"monthly-limit-reached"|"sending-paused"|"sending-suspended"|"account-suspended"|"sending-backlogged" queuedReason?;
    # the email address of the recipient
    string email?;
    # the sending status of the recipient
    "sent"|"queued"|"rejected"|"invalid" status?;
};

public type IpsInfoBody record {
    # a dedicated IP address
    string ip?;
    # a valid api key
    string 'key;
};

# the sending results for a single recipient
public type InlineResponse20028 record {
    # the reason for the rejection if the recipient status is "rejected"
    @jsondata:Name {value: "reject_reason"}
    "hard-bounce"|"soft-bounce"|"spam"|"unsub"|"custom"|"invalid-sender"|"invalid"|"test-mode-limit"|"unsigned"|"rule" rejectReason?;
    # the message's unique id
    @jsondata:Name {value: "_id"}
    string id?;
    # the reason for the email being queued if the response status is "queued"
    @jsondata:Name {value: "queued_reason"}
    "attachments"|"multiple-recipients"|"free-trial-sends-exhausted"|"hourly-quota-exhausted"|"monthly-limit-reached"|"sending-paused"|"sending-suspended"|"account-suspended"|"sending-backlogged" queuedReason?;
    # the email address of the recipient
    string email?;
    # the sending status of the recipient
    "sent"|"queued"|"scheduled"|"rejected"|"invalid" status?;
};

public type IpsCheckCustomDnsBody record {
    # a dedicated ip address
    string ip;
    # the domain name to test
    string domain;
    # a valid api key
    string 'key;
};

public type InboundSendRawBody record {
    # the identification provided by the client mta in the MTA state of the SMTP conversation. Required for the SPF check
    string helo?;
    # the full MIME document of an email message
    @jsondata:Name {value: "raw_message"}
    string rawMessage;
    # optionally define the recipients to receive the message - otherwise we'll use the To, Cc, and Bcc headers provided in the document
    string[] to?;
    # the address specified in the MAIL FROM stage of the SMTP conversation. Required for the SPF check
    @jsondata:Name {value: "mail_from"}
    string mailFrom?;
    # the remote MTA's ip address. Optional; required for the SPF check
    @jsondata:Name {value: "client_address"}
    string clientAddress?;
    # a valid api key
    string 'key;
};

# the sender that this denylist entry applies to, or null if none
public type RejectslistSender record {
    # the total number of rejected messages by this sender
    int rejects?;
    # the sender's email address
    string address?;
    # the total number of hard bounces by messages by this sender
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent for this sender
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the total number of unsubscribe requests received for messages by this sender
    int unsubs?;
    # the total number of spam complaints received for messages by this sender
    int complaints?;
    # the date and time that the sender was first seen by Mandrill as a UTC date string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the total number of times messages by this sender have been opened
    int opens?;
    # the total number of times tracked URLs in messages by this sender have been clicked
    int clicks?;
    # the total number of soft bounces by messages by this sender
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the total number of messages sent by this sender
    int sent?;
    # the number of unique opens for emails sent for this sender
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# tats for the lifetime of the user's account
public type InlineResponse20072StatsAllTime record {
    # the number of emails rejected for sending this user so far today
    int rejects?;
    # the number of emails hard bounced in the lifetime of the user's account
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent in the lifetime of the user's account
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes in the lifetime of the user's account
    int unsubs?;
    # the number of spam complaints in the lifetime of the user's account
    int complaints?;
    # the number of times emails have been opened in the lifetime of the user's account
    int opens?;
    # the number of URLs that have been clicked in the lifetime of the user's account
    int clicks?;
    # the number of emails soft bounced in the lifetime of the user's account
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent in the lifetime of the user's account
    int sent?;
    # the number of unique opens for emails sent in the lifetime of the user's account
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

public type TemplatesListBody record {
    # an optional label to filter the templates
    string label?;
    # a valid api key
    string 'key;
};

# stats for this user in the last 7 days
public type InlineResponse20072StatsLast7Days record {
    # the number of emails rejected for sending this sender in the last 7 days
    int rejects?;
    # the number of emails hard bounced for this user in the last 7 days
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent for this user in the last 7 days
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes for this user in the last 7 days
    int unsubs?;
    # the number of spam complaints for this user in the last 7 days
    int complaints?;
    # the number of times emails have been opened for this user in the last 7 days
    int opens?;
    # the number of URLs that have been clicked for this user in the last 7 days
    int clicks?;
    # the number of emails soft bounced for this user in the last 7 days
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent for this user in the last 7 days
    int sent?;
    # the number of unique opens for emails sent for this user in the last 7 days
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# stats with this tag in the last 60 days
public type InlineResponse20059StatsLast60Days record {
    # the number of emails rejected for sending this sender in the last 60 days
    int rejects?;
    # the number of emails hard bounced with this tag in the last 60 days
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent with this tag in the last 60 days
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes with this tag in the last 60 days
    int unsubs?;
    # the number of spam complaints with this tag in the last 60 days
    int complaints?;
    # the number of times emails have been opened with this tag in the last 60 days
    int opens?;
    # the number of URLs that have been clicked with this tag in the last 60 days
    int clicks?;
    # the number of emails soft bounced with this tag in the last 60 days
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent with this tag in the last 60 days
    int sent?;
    # the number of unique opens for emails sent with this tag in the last 60 days
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

public type InboundAddRouteBody record {
    # an existing inbound domain
    string domain;
    # the search pattern that the mailbox name should match
    string pattern;
    # a valid api key
    string 'key;
    # the webhook URL where the inbound messages will be published
    string url;
};

# the information for a single matching message
public type InlineResponse20030 record {
    # the unique name of the template used, if any
    string template?;
    # any custom metadata provided when the message was sent
    record {} metadata?;
    # the message's subject line
    string subject?;
    # list of individual clicks for the message
    @jsondata:Name {value: "clicks_detail"}
    MessagessearchClicksDetail[] clicksDetail?;
    # list of tags on this message
    string[] tags?;
    # list of individual opens for the message
    @jsondata:Name {value: "opens_detail"}
    MessagessearchOpensDetail[] opensDetail?;
    # the email address of the sender
    string sender?;
    # how many times has this message been opened
    int opens?;
    # how many times has a link been clicked in this message
    int clicks?;
    # the message's unique id
    @jsondata:Name {value: "_id"}
    string id?;
    # sending status of this message
    "sent"|"bounced"|"rejected" state?;
    # the recipient email address
    string email?;
    # the Unix timestamp from when this message was sent
    int ts?;
};

# stats for this user so far today
public type InlineResponse20072StatsToday record {
    # the number of emails rejected for sending this sender so far today
    int rejects?;
    # the number of emails hard bounced for this user so far today
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent for this user so far today
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes for this user so far today
    int unsubs?;
    # the number of spam complaints for this user so far today
    int complaints?;
    # the number of times emails have been opened for this user so far today
    int opens?;
    # the number of URLs that have been clicked for this user so far today
    int clicks?;
    # the number of emails soft bounced for this user so far today
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent for this user so far today
    int sent?;
    # the number of unique opens for emails sent for this user so far today
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# the information for the message
public type InlineResponse20032 record {
    # the unique name of the template used, if any
    string template?;
    # any custom metadata provided when the message was sent
    record {} metadata?;
    # the message's subject line
    string subject?;
    # list of individual clicks for the message
    @jsondata:Name {value: "clicks_detail"}
    MessagessearchClicksDetail[] clicksDetail?;
    # list of tags on this message
    string[] tags?;
    # list of individual opens for the message
    @jsondata:Name {value: "opens_detail"}
    MessagessearchOpensDetail[] opensDetail?;
    # the email address of the sender
    string sender?;
    # how many times has this message been opened
    int opens?;
    # how many times has a link been clicked in this message
    int clicks?;
    # the message's unique id
    @jsondata:Name {value: "_id"}
    string id?;
    # sending status of this message
    "sent"|"bounced"|"rejected" state?;
    # a log of up to 3 smtp events for the message
    @jsondata:Name {value: "smtp_events"}
    InlineResponse20032SmtpEvents[] smtpEvents?;
    # the recipient email address
    string email?;
    # the Unix timestamp from when this message was sent
    int ts?;
};

# the stats for a single hour
public type InlineResponse20031 record {
    # the number of emails that were rejected during the hour
    int rejects?;
    # the number of emails that hard bounced during the hour
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks generated by messages sent during the hour
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes received during the hour
    int unsubs?;
    # the number of spam complaints received during the hour
    int complaints?;
    # the number of emails opened during the hour
    int opens?;
    # the number of tracked URLs clicked during the hour
    int clicks?;
    # the number of emails that soft bounced during the hour
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the hour as a UTC date string in YYYY-MM-DD HH:MM:SS format
    string time?;
    # the number of emails that were sent during the hour
    int sent?;
    # the number of unique opens generated by messages sent during the hour
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# the parsed message
public type InlineResponse20034 record {
    # the key-value pairs of the MIME headers for the message's main document
    record {} headers?;
    # an array of any embedded images that can be found in the message
    InlineResponse20034Images[] images?;
    # the email address of the sender
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # an array of any attachments that can be found in the message
    InlineResponse20034Attachments[] attachments?;
    # the subject of the message
    string subject?;
    # the HTML part of the message, if any
    string html?;
    # an array of any recipients in the message
    InlineResponse20034To[] to?;
    # the text part of the message, if any
    string text?;
    # the alias of the sender (if any)
    @jsondata:Name {value: "from_name"}
    string fromName?;
};

# the content of the message
public type InlineResponse20033 record {
    # the key-value pairs of the custom MIME headers for the message's main document
    record {} headers?;
    # the email address of the sender
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # an array of any attachments that can be found in the message
    InlineResponse20033Attachments[] attachments?;
    # the message's subject line
    string subject?;
    # the HTML part of the message, if any
    string html?;
    # the message's unique id
    @jsondata:Name {value: "_id"}
    string id?;
    # the message recipient's information
    InlineResponse20033To to?;
    # the text part of the message, if any
    string text?;
    # the alias of the sender (if any)
    @jsondata:Name {value: "from_name"}
    string fromName?;
    # the Unix timestamp from when this message was sent
    int ts?;
    # list of tags on this message
    string[] tags?;
};

# the individual custom metadata field info
public type InlineResponse20036 record {
    # the unique identifier of the metadata field to update
    string name?;
    # the current state of the metadata field
    "active"|"delete"|"index" state?;
    # Mustache template to control how the metadata is rendered in your activity log
    @jsondata:Name {value: "view_template"}
    string viewTemplate?;
};

# a scheduled email
public type InlineResponse20035 record {
    # the email's sender address
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # the email's subject
    string subject?;
    # the UTC timestamp when the message was created, in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the UTC timestamp when the message will be sent, in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "send_at"}
    string sendAt?;
    # the scheduled message id
    @jsondata:Name {value: "_id"}
    string id?;
    # the email's recipient
    string to?;
};

# the information for the updated metadata field
public type InlineResponse20038 record {
    # the unique identifier of the metadata field to update
    string name?;
    # the current state of the metadata field
    "active"|"delete"|"index" state?;
    # Mustache template to control how the metadata is rendered in your activity log
    @jsondata:Name {value: "view_template"}
    string viewTemplate?;
};

# the information saved about the new metadata field
public type InlineResponse20037 record {
    # the unique identifier of the metadata field to update
    string name?;
    # the current state of the metadata field
    "active"|"delete"|"index" state?;
    # Mustache template to control how the metadata is rendered in your activity log
    @jsondata:Name {value: "view_template"}
    string viewTemplate?;
};

# the information for the deleted metadata field
public type InlineResponse20039 record {
    # the unique identifier of the metadata field to update
    string name?;
    # the current state of the metadata field
    "active"|"delete"|"index" state?;
    # Mustache template to control how the metadata is rendered in your activity log
    @jsondata:Name {value: "view_template"}
    string viewTemplate?;
};

# the information for each rejection  entry
public type InlineResponse20041 record {
    # the type of event (hard-bounce, soft-bounce, spam, unsub, custom) that caused this rejection
    string reason?;
    # the timestamp of the most recent event that either created or renewed this rejection
    @jsondata:Name {value: "last_event_at"}
    string lastEventAt?;
    # when the denylist entry will expire (this may be in the past)
    @jsondata:Name {value: "expires_at"}
    string expiresAt?;
    # whether the denylist entry has expired
    boolean expired?;
    # the sender that this denylist entry applies to, or null if none
    RejectslistSender sender?;
    # the subaccount that this denylist entry applies to, or null if none
    string subaccount?;
    # when the email was added to the denylist
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # extended details about the event, such as the SMTP diagnostic for bounces or the comment for manually-created rejections
    string detail?;
    # the email that is blocked
    string email?;
};

# a status object containing the address and the result of the operation
public type InlineResponse20040 record {
    # whether the operation succeeded
    boolean added?;
    # the email address you provided
    string email?;
};

# the information on each sending address in the account
public type InlineResponse20043 record {
    # the total number of rejected messages by this sender
    int rejects?;
    # the sender's email address
    string address?;
    # the total number of hard bounces by messages by this sender
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent for this sender
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the total number of unsubscribe requests received for messages by this sender
    int unsubs?;
    # the total number of spam complaints received for messages by this sender
    int complaints?;
    # the date and time that the sender was first seen by Mandrill as a UTC date string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the total number of times messages by this sender have been opened
    int opens?;
    # the total number of times tracked URLs in messages by this sender have been clicked
    int clicks?;
    # the total number of soft bounces by messages by this sender
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the total number of messages sent by this sender
    int sent?;
    # the number of unique opens for emails sent for this sender
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# stats for this sender so far today
public type InlineResponse20048StatsToday record {
    # the number of emails rejected for sending this sender so far today
    int rejects?;
    # the number of emails hard bounced for this sender so far today
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent for this sender so far today
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes for this sender so far today
    int unsubs?;
    # the number of spam complaints for this sender so far today
    int complaints?;
    # the number of times emails have been opened for this sender so far today
    int opens?;
    # the number of URLs that have been clicked for this sender so far today
    int clicks?;
    # the number of emails soft bounced for this sender so far today
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent for this sender so far today
    int sent?;
    # the number of unique opens for emails sent for this sender so far today
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# a status object containing the address and whether the deletion succeeded
public type InlineResponse20042 record {
    # whether the address was deleted successfully
    boolean deleted?;
    # the subaccount denylist that the address was removed from, if any
    string subaccount?;
    # the email address that was removed from the denylist
    string email?;
};

# information about the domain
public type InlineResponse20045 record {
    # whether this domain can be used to authenticate mail, either for itself or as a custom signing domain. If this is false but spf and dkim are both valid, you will need to verify the domain before using it to authenticate mail
    @jsondata:Name {value: "valid_signing"}
    boolean validSigning?;
    # a unique key used to verify a domain by adding a TXT record. Append this key to 'mandrill_verify.' and add it to your domain's TXT records to verify
    @jsondata:Name {value: "verify_txt_key"}
    string verifyTxtKey?;
    # when the domain's DNS settings were last tested as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "last_tested_at"}
    string lastTestedAt?;
    # details about the domain's DKIM record
    InlineResponse20045Dkim dkim?;
    # if the domain has been verified, this indicates when that verification occurred as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "verified_at"}
    string verifiedAt?;
    # the sender domain name
    string domain?;
    # details about the domain's SPF record
    SendersdomainsSpf spf?;
    # the date and time that the sending domain was first seen as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
};

# information about an individual attachment
public type InlineResponse20033Attachments record {
    # the file name of the attachment
    string name?;
    # the MIME type of the attachment
    string 'type?;
    # the content of the attachment as a base64 encoded string
    string content?;
};

# the information on each sending domain for the account
public type InlineResponse20044 record {
    # whether this domain can be used to authenticate mail, either for itself or as a custom signing domain. If this is false but spf and dkim are both valid, you will need to verify the domain before using it to authenticate mail
    @jsondata:Name {value: "valid_signing"}
    boolean validSigning?;
    # a unique key used to verify a domain by adding a TXT record. Append this key to 'mandrill_verify.' and add it to your domain's TXT records to verify
    @jsondata:Name {value: "verify_txt_key"}
    string verifyTxtKey?;
    # when the domain's DNS settings were last tested as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "last_tested_at"}
    string lastTestedAt?;
    # details about the domain's Legacy DKIM record
    SendersdomainsDkim dkim?;
    # details about the domain's rotatable 2048 bit DKIM record
    SendersdomainsDkim2 dkim2?;
    # if the domain has been verified, this indicates when that verification occurred as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "verified_at"}
    string verifiedAt?;
    # the sender domain name
    string domain?;
    # details about the domain's SPF record
    SendersdomainsSpf spf?;
    # the date and time that the sending domain was first seen as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # details about the domain's DMARC record
    SendersdomainsDmarc dmarc?;
};

# details about the domain's rotatable 2048 bit DKIM record
public type SendersdomainsDkim2 record {
    # whether the domain's DKIM record is valid for use with Mandrill
    boolean valid?;
    # when the domain's DKIM record will be considered valid for use with Mandrill as a UTC string in YYYY-MM-DD HH:MM:SS format. If set, this indicates that the record is valid now, but was previously invalid, and Mandrill will wait until the record's TTL elapses to start using it
    @jsondata:Name {value: "valid_after"}
    string validAfter?;
    # an error describing the DKIM record, or null if the record is correct
    string 'error?;
};

# information about the verification that was sent
public type InlineResponse20047 record {
    # the domain name you provided
    string domain?;
    # the email address the verification email was sent to
    string email?;
    # "sent" indicates that the verification has been sent, "already_verified" indicates that the domain has already been verified with your account
    string status?;
};

# information about the sender domain
public type InlineResponse20046 record {
    # whether this domain can be used to authenticate mail, either for itself or as a custom signing domain. If this is false but spf and dkim are both valid, you will need to verify the domain before using it to authenticate mail
    @jsondata:Name {value: "valid_signing"}
    boolean validSigning?;
    # a unique key used to verify a domain by adding a TXT record. Append this key to 'mandrill_verify.' and add it to your domain's TXT records to verify
    @jsondata:Name {value: "verify_txt_key"}
    string verifyTxtKey?;
    # when the domain's DNS settings were last tested as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "last_tested_at"}
    string lastTestedAt?;
    # details about the domain's Legacy DKIM record
    SendersdomainsDkim dkim?;
    # details about the domain's rotatable 2048 bit DKIM record
    SendersdomainsDkim2 dkim2?;
    # if the domain has been verified, this indicates when that verification occurred as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "verified_at"}
    string verifiedAt?;
    # the sender domain name
    string domain?;
    # details about the domain's SPF record
    SendersdomainsSpf spf?;
    # the date and time that the sending domain was first seen as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # details about the domain's DMARC record
    SendersdomainsDmarc dmarc?;
};

# the stats for a single hour
public type InlineResponse20049 record {
    # the number of emails that were rejected during the hour
    int rejects?;
    # the number of emails that hard bounced during the hour
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks generated by messages sent during the hour
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of spam complaints received during the hour
    int complaints?;
    # the number of emails opened during the hour
    int opens?;
    # the number of tracked URLs clicked during the hour
    int clicks?;
    # the number of emails that soft bounced during the hour
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the hour as a UTC date string in YYYY-MM-DD HH:MM:SS format
    string time?;
    # the number of emails that were sent during the hour
    int sent?;
    # the number of unique opens generated by messages sent during the hour
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# metadata an associative array of user metadata. Mandrill will store this metadata and make it available for retrieval. In addition, you can select up to 10 metadata fields to index and make searchable using the Mandrill search api
public type MessagessendMessageMetadata record {
    # a valid website url
    string website?;
};

# the detailed information on the sender
public type InlineResponse20048 record {
    # the total number of rejected messages by this sender
    int rejects?;
    # the sender's email address
    string address?;
    # the total number of hard bounces by messages by this sender
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # an aggregate summary of the sender's sending stats
    InlineResponse20048Stats stats?;
    # the total number of unsubscribe requests received for messages by this sender
    int unsubs?;
    # the total number of spam complaints received for messages by this sender
    int complaints?;
    # the date and time that the sender was first seen by Mandrill as a UTC date string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the total number of times messages by this sender have been opened
    int opens?;
    # the total number of times tracked URLs in messages by this sender have been clicked
    int clicks?;
    # the total number of soft bounces by messages by this sender
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the total number of messages sent by this sender
    int sent?;
};

public type TagsInfoBody record {
    # an existing tag name
    string tag;
    # a valid api key
    string 'key;
};

public type SendersVerifyDomainBody record {
    # a mailbox at the domain where the verification email should be sent
    string mailbox;
    # domain name at which you can receive email
    string domain;
    # a valid api key
    string 'key;
};

# stats for this subaccount in the last 30 days
public type InlineResponse20052Last30Days record {
    # the number of emails rejected for sending this subaccount in the last 30 days
    int rejects?;
    # the number of emails hard bounced for this subaccount in the last 30 days
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent for this subaccount in the last 30 days
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsbuscribes for this subaccount in the last 30 days
    int unsubs?;
    # the number of spam complaints for this subaccount in the last 30 days
    int complaints?;
    # the number of times emails have been opened for this subaccount in the last 30 days
    int opens?;
    # the number of URLs that have been clicked for this subaccount in the last 30 days
    int clicks?;
    # the number of emails soft bounced for this subaccount in the last 30 days
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent for this subaccount in the last 30 days
    int sent?;
    # the number of unique opens for emails sent for this subaccount in the last 30 days
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# stats for this user in the last 30 days
public type InlineResponse20072StatsLast30Days record {
    # the number of emails rejected for sending this sender in the last 30 days
    int rejects?;
    # the number of emails hard bounced for this user in the last 30 days
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent for this user in the last 30 days
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes for this user in the last 30 days
    int unsubs?;
    # the number of spam complaints for this user in the last 30 days
    int complaints?;
    # the number of times emails have been opened for this user in the last 30 days
    int opens?;
    # the number of URLs that have been clicked for this user in the last 30 days
    int clicks?;
    # the number of emails soft bounced for this user in the last 30 days
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent for this user in the last 30 days
    int sent?;
    # the number of unique opens for emails sent for this user in the last 30 days
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

public type UrlsTimeSeriesBody record {
    # a valid api key
    string 'key;
    # an existing URL
    string url;
};

public type UrlsCheckTrackingDomainBody record {
    # an existing tracking domain name
    string domain;
    # a valid api key
    string 'key;
};

public type IpsStartWarmupBody record {
    # a dedicated ip address
    string ip;
    # a valid api key
    string 'key;
};

# the individual subaccount info
public type InlineResponse20050 record {
    # an optional manual hourly quota for the subaccount. If not specified, the hourly quota will be managed based on reputation
    @jsondata:Name {value: "custom_quota"}
    int customQuota?;
    # an optional display name for the subaccount
    string name?;
    # the date and time that the subaccount first sent as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "first_sent_at"}
    string firstSentAt?;
    # the subaccount's current reputation on a scale from 0 to 100
    @constraint:Int {minValue: 0, maxValue: 100}
    int reputation?;
    # the date and time that the subaccount was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the number of emails the subaccount has sent since it was created
    @jsondata:Name {value: "sent_total"}
    int sentTotal?;
    # a unique indentifier for the subaccount
    string id?;
    # the number of emails the subaccount has sent so far this month (months start on midnight of the 1st, UTC)
    @jsondata:Name {value: "sent_monthly"}
    int sentMonthly?;
    # the number of emails the subaccount has sent so far this week (weeks start on midnight Monday, UTC)
    @jsondata:Name {value: "sent_weekly"}
    int sentWeekly?;
    # the current sending status of the subaccount
    "active"|"paused" status?;
};

# the information about the subaccount
public type InlineResponse20052 record {
    # optional extra text to associate with the subaccount
    string notes?;
    # an optional manual hourly quota for the subaccount. If not specified, the hourly quota will be managed based on reputation
    @jsondata:Name {value: "custom_quota"}
    int customQuota?;
    # the date and time that the subaccount first sent as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "first_sent_at"}
    string firstSentAt?;
    # the subaccount's current reputation on a scale from 0 to 100
    @constraint:Int {minValue: 0, maxValue: 100}
    int reputation?;
    # the date and time that the subaccount was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    @jsondata:Name {value: "last_30_days"}
    InlineResponse20052Last30Days last30Days?;
    # the number of emails the subaccount has sent so far this week (weeks start on midnight Monday, UTC)
    @jsondata:Name {value: "sent_weekly"}
    int sentWeekly?;
    # the current hourly quota for the subaccount, either manual or reputation-based
    @jsondata:Name {value: "hourly_quota"}
    int hourlyQuota?;
    # an optional display name for the subaccount
    string name?;
    # the number of emails the subaccount has sent since it was created
    @jsondata:Name {value: "sent_total"}
    int sentTotal?;
    # the number of emails the subaccount has sent in the last hour
    @jsondata:Name {value: "sent_hourly"}
    int sentHourly?;
    # a unique indentifier for the subaccount
    string id?;
    # the number of emails the subaccount has sent so far this month (months start on midnight of the 1st, UTC)
    @jsondata:Name {value: "sent_monthly"}
    int sentMonthly?;
    # the current sending status of the subaccount
    "active"|"paused" status?;
};

# the information saved about the new subaccount
public type InlineResponse20051 record {
    # an optional manual hourly quota for the subaccount. If not specified, the hourly quota will be managed based on reputation
    @jsondata:Name {value: "custom_quota"}
    int customQuota?;
    # an optional display name for the subaccount
    string name?;
    # the date and time that the subaccount first sent as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "first_sent_at"}
    string firstSentAt?;
    # the subaccount's current reputation on a scale from 0 to 100
    @constraint:Int {minValue: 0, maxValue: 100}
    int reputation?;
    # the date and time that the subaccount was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the number of emails the subaccount has sent since it was created
    @jsondata:Name {value: "sent_total"}
    int sentTotal?;
    # a unique indentifier for the subaccount
    string id?;
    # the number of emails the subaccount has sent so far this month (months start on midnight of the 1st, UTC)
    @jsondata:Name {value: "sent_monthly"}
    int sentMonthly?;
    # the number of emails the subaccount has sent so far this week (weeks start on midnight Monday, UTC)
    @jsondata:Name {value: "sent_weekly"}
    int sentWeekly?;
    # the current sending status of the subaccount
    "active"|"paused" status?;
};

# the information for the deleted subaccount
public type InlineResponse20054 record {
    # an optional manual hourly quota for the subaccount. If not specified, the hourly quota will be managed based on reputation
    @jsondata:Name {value: "custom_quota"}
    int customQuota?;
    # an optional display name for the subaccount
    string name?;
    # the date and time that the subaccount first sent as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "first_sent_at"}
    string firstSentAt?;
    # the subaccount's current reputation on a scale from 0 to 100
    @constraint:Int {minValue: 0, maxValue: 100}
    int reputation?;
    # the date and time that the subaccount was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the number of emails the subaccount has sent since it was created
    @jsondata:Name {value: "sent_total"}
    int sentTotal?;
    # a unique indentifier for the subaccount
    string id?;
    # the number of emails the subaccount has sent so far this month (months start on midnight of the 1st, UTC)
    @jsondata:Name {value: "sent_monthly"}
    int sentMonthly?;
    # the number of emails the subaccount has sent so far this week (weeks start on midnight Monday, UTC)
    @jsondata:Name {value: "sent_weekly"}
    int sentWeekly?;
    # the current sending status of the subaccount
    "active"|"paused" status?;
};

# the information for the updated subaccount
public type InlineResponse20053 record {
    # an optional manual hourly quota for the subaccount. If not specified, the hourly quota will be managed based on reputation
    @jsondata:Name {value: "custom_quota"}
    int customQuota?;
    # an optional display name for the subaccount
    string name?;
    # the date and time that the subaccount first sent as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "first_sent_at"}
    string firstSentAt?;
    # the subaccount's current reputation on a scale from 0 to 100
    @constraint:Int {minValue: 0, maxValue: 100}
    int reputation?;
    # the date and time that the subaccount was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the number of emails the subaccount has sent since it was created
    @jsondata:Name {value: "sent_total"}
    int sentTotal?;
    # a unique indentifier for the subaccount
    string id?;
    # the number of emails the subaccount has sent so far this month (months start on midnight of the 1st, UTC)
    @jsondata:Name {value: "sent_monthly"}
    int sentMonthly?;
    # the number of emails the subaccount has sent so far this week (weeks start on midnight Monday, UTC)
    @jsondata:Name {value: "sent_weekly"}
    int sentWeekly?;
    # the current sending status of the subaccount
    "active"|"paused" status?;
};

# the information for the resumed subaccount
public type InlineResponse20056 record {
    # an optional manual hourly quota for the subaccount. If not specified, the hourly quota will be managed based on reputation
    @jsondata:Name {value: "custom_quota"}
    int customQuota?;
    # an optional display name for the subaccount
    string name?;
    # the date and time that the subaccount first sent as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "first_sent_at"}
    string firstSentAt?;
    # the subaccount's current reputation on a scale from 0 to 100
    @constraint:Int {minValue: 0, maxValue: 100}
    int reputation?;
    # the date and time that the subaccount was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the number of emails the subaccount has sent since it was created
    @jsondata:Name {value: "sent_total"}
    int sentTotal?;
    # a unique indentifier for the subaccount
    string id?;
    # the number of emails the subaccount has sent so far this month (months start on midnight of the 1st, UTC)
    @jsondata:Name {value: "sent_monthly"}
    int sentMonthly?;
    # the number of emails the subaccount has sent so far this week (weeks start on midnight Monday, UTC)
    @jsondata:Name {value: "sent_weekly"}
    int sentWeekly?;
    # the current sending status of the subaccount
    "active"|"paused" status?;
};

# the information for the paused subaccount
public type InlineResponse20055 record {
    # an optional manual hourly quota for the subaccount. If not specified, the hourly quota will be managed based on reputation
    @jsondata:Name {value: "custom_quota"}
    int customQuota?;
    # an optional display name for the subaccount
    string name?;
    # the date and time that the subaccount first sent as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "first_sent_at"}
    string firstSentAt?;
    # the subaccount's current reputation on a scale from 0 to 100
    @constraint:Int {minValue: 0, maxValue: 100}
    int reputation?;
    # the date and time that the subaccount was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # the number of emails the subaccount has sent since it was created
    @jsondata:Name {value: "sent_total"}
    int sentTotal?;
    # a unique indentifier for the subaccount
    string id?;
    # the number of emails the subaccount has sent so far this month (months start on midnight of the 1st, UTC)
    @jsondata:Name {value: "sent_monthly"}
    int sentMonthly?;
    # the number of emails the subaccount has sent so far this week (weeks start on midnight Monday, UTC)
    @jsondata:Name {value: "sent_weekly"}
    int sentWeekly?;
    # the current sending status of the subaccount
    "active"|"paused" status?;
};

# the tag that was deleted
public type InlineResponse20058 record {
    # the total number of rejected messages with this tag
    int rejects?;
    # the total number of hard bounces by messages with this tag
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent with this tag
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the total number of unsubscribe requests received for messages with this tag
    int unsubs?;
    # the total number of spam complaints received for messages with this tag
    int complaints?;
    # the tag's current reputation on a scale from 0 to 100
    @constraint:Int {minValue: 0, maxValue: 100}
    int reputation?;
    # the total number of times messages with this tag have been opened
    int opens?;
    # the total number of times tracked URLs in messages with this tag have been clicked
    int clicks?;
    # the total number of soft bounces by messages with this tag
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the actual tag as a string
    string tag?;
    # the total number of messages sent with this tag
    int sent?;
    # the number of unique opens for emails sent with this tag
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# a user-defined tag
public type InlineResponse20057 record {
    # the total number of rejected messages with this tag
    int rejects?;
    # the total number of hard bounces by messages with this tag
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent with this tag
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the total number of unsubscribe requests received for messages with this tag
    int unsubs?;
    # the total number of spam complaints received for messages with this tag
    int complaints?;
    # the tag's current reputation on a scale from 0 to 100
    @constraint:Int {minValue: 0, maxValue: 100}
    int reputation?;
    # the total number of times messages with this tag have been opened
    int opens?;
    # the total number of times tracked URLs in messages with this tag have been clicked
    int clicks?;
    # the total number of soft bounces by messages with this tag
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the actual tag as a string
    string tag?;
    # the total number of messages sent with this tag
    int sent?;
    # the number of unique opens for emails sent with this tag
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# the detailed information on the tag
public type InlineResponse20059 record {
    # the total number of rejected messages with this tag
    int rejects?;
    # the total number of hard bounces by messages with this tag
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # an aggregate summary of the tag's sending stats
    InlineResponse20059Stats stats?;
    # the total number of unsubscribe requests received for messages with this tag
    int unsubs?;
    # the total number of spam complaints received for messages with this tag
    int complaints?;
    # the total number of times messages with this tag have been opened
    int opens?;
    # the total number of times tracked URLs in messages with this tag have been clicked
    int clicks?;
    # the total number of soft bounces by messages with this tag
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the actual tag as a string
    string tag?;
    # the total number of messages sent with this tag
    int sent?;
};

# per-recipient merge variables
public type MessagessendMessageMergeVars record {
    # the email address of the recipient that the merge variables should apply to
    string rcpt;
    # the recipient's merge variables
    MessagessendMessageVars[] vars?;
};

public type TemplatesUpdateBody record {
    # the new default sending address
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # the new code for the template
    string code?;
    # the new default subject line
    string subject?;
    # set to false to update the draft version of the template without publishing
    boolean publish?;
    # the immutable name of an existing template
    string name;
    # the new default text part to be used
    string text?;
    # the new default from name
    @jsondata:Name {value: "from_name"}
    string fromName?;
    # a valid api key
    string 'key;
    # an optional array of up to 10 labels to use for filtering templates
    @constraint:Array {maxLength: 10}
    TemplatesUpdateBodyLabelsItemsString[] labels?;
};

public type AllowlistsDeleteBody record {
    # a valid api key
    string 'key;
    # the email address to remove from the allowlist
    string email;
};

public type RejectsDeleteBody record {
    # an optional unique identifier for the subaccount to limit the denylist deletion
    @constraint:String {maxLength: 255}
    string subaccount?;
    # a valid api key
    string 'key;
    # an email address
    string email;
};

public type MessagesListScheduledBody record {
    # an optional recipient address to restrict results to
    string to?;
    # a valid api key
    string 'key;
};

public type InboundUpdateRouteBody record {
    # the search pattern that the mailbox name should match
    string pattern?;
    # the unique identifier of an existing mailbox route
    string id;
    # a valid api key
    string 'key;
    # the webhook URL where the inbound messages will be published; Validation: webhookexists
    string url?;
};

# stats for this sender in the last 60 days
public type InlineResponse20048StatsLast60Days record {
    # the number of emails rejected for sending this sender in the last 60 days
    int rejects?;
    # the number of emails hard bounced for this sender in the last 60 days
    @jsondata:Name {value: "hard_bounces"}
    int hardBounces?;
    # the number of unique clicks for emails sent for this sender in the last 60 days
    @jsondata:Name {value: "unique_clicks"}
    int uniqueClicks?;
    # the number of unsubscribes for this sender in the last 60 days
    int unsubs?;
    # the number of spam complaints for this sender in the last 60 days
    int complaints?;
    # the number of times emails have been opened for this sender in the last 60 days
    int opens?;
    # the number of URLs that have been clicked for this sender in the last 60 days
    int clicks?;
    # the number of emails soft bounced for this sender in the last 60 days
    @jsondata:Name {value: "soft_bounces"}
    int softBounces?;
    # the number of emails sent for this sender in the last 60 days
    int sent?;
    # the number of unique opens for emails sent for this sender in the last 60 days
    @jsondata:Name {value: "unique_opens"}
    int uniqueOpens?;
};

# the injection of a single piece of content into a single editable region
public type MessagessendTemplateTemplateContent record {
    # the name of the mc:edit editable region to inject into
    string name?;
    # the content to inject
    string content?;
};

public type SubaccountsListBody record {
    # an optional prefix to filter the subaccounts' ids and names
    string q?;
    # a valid api key
    string 'key;
};

public type WebhooksAddBody record {
    # an optional description of the webhook
    string description?;
    # a valid api key
    string 'key;
    # the URL to POST batches of events
    string url;
    # an optional list of events that will be posted to the webhook
    record {}[] events?;
};

public type SendersAddDomainBody record {
    # a domain name
    string domain;
    # a valid api key
    string 'key;
};

# information about the ip's custom dns, if it has been configured
public type IpslistCustomDns record {
    # whether the ip's custom dns is currently valid
    boolean valid?;
    # if the ip's custom dns is invalid, this will include details about the error
    string 'error?;
    # a boolean indicating whether custom dns has been configured for this ip
    boolean enabled?;
};

public type MessagesSearchTimeSeriesBody record {
    # the search terms to find matching messages for
    string query?;
    # end date
    @jsondata:Name {value: "date_to"}
    string dateTo?;
    # an array of sender addresses to narrow the search to, will return messages sent by ANY of the senders
    string[] senders?;
    # a valid api key
    string 'key;
    # start date
    @jsondata:Name {value: "date_from"}
    string dateFrom?;
    # an array of tag names to narrow the search to, will return messages that contain ANY of the tags
    string[] tags?;
};

@constraint:String {maxLength: 100}
public type TemplatesUpdateBodyLabelsItemsString string;

public type MessagesParseBody record {
    # the full MIME document of an email message
    @jsondata:Name {value: "raw_message"}
    string rawMessage;
    # a valid api key
    string 'key;
};

# details about the domain's SPF record
public type SendersdomainsSpf record {
    # whether the domain's SPF record is valid for use with Mandrill
    boolean valid?;
    # when the domain's SPF record will be considered valid for use with Mandrill as a UTC string in YYYY-MM-DD HH:MM:SS format. If set, this indicates that the record is valid now, but was previously invalid, and Mandrill will wait until the record's TTL elapses to start using it
    @jsondata:Name {value: "valid_after"}
    string validAfter?;
    # an error describing the spf record, or null if the record is correct
    string 'error?;
};

# a status object containing the address and the result of the operation
public type InlineResponse200 record {
    # whether the operation succeeded
    boolean added?;
    # the email address you provided
    string email?;
};

# an aggregate summary of the sender's sending stats
public type InlineResponse20048Stats record {
    @jsondata:Name {value: "last_7_days"}
    InlineResponse20048StatsLast7Days last7Days?;
    # stats for this sender so far today
    InlineResponse20048StatsToday today?;
    @jsondata:Name {value: "last_90_days"}
    InlineResponse20048StatsLast90Days last90Days?;
    @jsondata:Name {value: "last_30_days"}
    InlineResponse20048StatsLast30Days last30Days?;
    @jsondata:Name {value: "last_60_days"}
    InlineResponse20048StatsLast60Days last60Days?;
};

public type SubaccountsResumeBody record {
    # the unique identifier of the subaccount to resume
    string id;
    # a valid api key
    string 'key;
};

public type ExportsActivityBody record {
    # an optional email address to notify when the export job has finished
    @jsondata:Name {value: "notify_email"}
    string notifyEmail?;
    # end date as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "date_to"}
    string dateTo?;
    # an array of api keys to narrow the export to; messsagse sent with ANY of the keys will be included
    @jsondata:Name {value: "api_keys"}
    string[] apiKeys?;
    # an array of senders to narrow the export to
    string[] senders?;
    # a valid api key
    string 'key;
    # start date as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "date_from"}
    string dateFrom?;
    # an array of tag names to narrow the export to; will match messages that contain ANY of the tags
    string[] tags?;
    # an array of message states to narrow the export to; messages with ANY of the states will be included
    ("sent"|"rejected"|"bounced"|"soft-bounced"|"spam"|"unsub")[] states?;
};

public type MessagesSendRawBody record {
    # enable a background sending mode that is optimized for bulk sending. In async mode, messages/sendRaw will immediately return a status of "queued" for every recipient. To handle rejections when sending in async mode, set up a webhook for the 'reject' event. Defaults to false for messages with no more than 10 recipients; messages with more than 10 recipients are always sent asynchronously, regardless of the value of async
    boolean async?;
    # optionally define the sender address - otherwise we'll use the address found in the provided headers
    @jsondata:Name {value: "from_email"}
    string fromEmail?;
    # the full MIME document of an email message
    @jsondata:Name {value: "raw_message"}
    string rawMessage;
    # a custom domain to use for the messages's return-path
    @jsondata:Name {value: "return_path_domain"}
    string returnPathDomain?;
    # the name of the dedicated ip pool that should be used to send the message. If you do not have any dedicated IPs, this parameter has no effect. If you specify a pool that does not exist, your default pool will be used instead
    @jsondata:Name {value: "ip_pool"}
    string ipPool?;
    # when this message should be sent as a UTC timestamp in YYYY-MM-DD HH:MM:SS format. If you specify a time in the past, the message will be sent immediately; for future dates, you're limited to one year from the date of scheduling
    @jsondata:Name {value: "send_at"}
    string sendAt?;
    # optionally define the recipient to receive the message - otherwise we'll use the To, Cc, and Bcc headers provided in the document
    string[] to?;
    # optionally define the sender alias
    @jsondata:Name {value: "from_name"}
    string fromName?;
    # a valid api key
    string 'key;
};

public type WebhooksInfoBody record {
    # the unique identifier of a webhook belonging to this account
    int id;
    # a valid api key
    string 'key;
};

public type IpsProvisionBody record {
    # the id of the pool to add the dedicated ip to, or null to use your account's default pool
    string pool?;
    # whether to enable warmup mode for the ip
    boolean warmup?;
    # a valid api key
    string 'key;
};

# metadata for a single recipient
public type MessagessendMessageRecipientMetadata record {
    # the email address of the recipient that the metadata is associated with
    string rcpt?;
    # an associated array containing the recipient's unique metadata. If a key exists in both the per-recipient metadata and the global metadata, the per-recipient metadata will be used
    MessagessendMessageValues values?;
};

public type SubaccountsUpdateBody record {
    # optional extra text to associate with the subaccount
    string notes?;
    # an optional manual hourly quota for the subaccount. If not specified, Mandrill will manage this based on reputation
    @jsondata:Name {value: "custom_quota"}
    int customQuota?;
    # an optional display name to further identify the subaccount
    @constraint:String {maxLength: 1024}
    string name?;
    # the unique identifier of the subaccount to update
    string id;
    # a valid api key
    string 'key;
};

public type MessagesCancelScheduledBody record {
    # a scheduled email id, as returned by any of the messages/send calls or messages/list-scheduled
    string id;
    # a valid api key
    string 'key;
};

public type AllowlistsListBody record {
    # a valid api key
    string 'key;
    # an optional email address or prefix to search by
    string email?;
};

public type MetadataAddBody record {
    # a unique identifier for the metadata field
    @constraint:String {maxLength: 64}
    string name;
    # Mustache template to control how the metadata is rendered in your activity log
    @jsondata:Name {value: "view_template"}
    string viewTemplate?;
    # a valid api key
    string 'key;
};

# information about the inbound domain
public type InlineResponse20010 record {
    # the domain name that is accepting mail
    string domain?;
    # true if this inbound domain has successfully set up an MX record to deliver mail to the Mandrill servers
    @jsondata:Name {value: "valid_mx"}
    boolean validMx?;
    # the date and time that the inbound domain was added as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
};

# the individual mailbox route
public type InlineResponse20012 record {
    # the search pattern that the mailbox name should match
    string pattern?;
    # the unique identifier of the route
    string id?;
    # the webhook URL where inbound messages will be published
    string url?;
};

public type SubaccountsPauseBody record {
    # the unique identifier of the subaccount to pause
    string id;
    # a valid api key
    string 'key;
};

# information about the deleted domain
public type InlineResponse20011 record {
    # the domain name that is accepting mail
    string domain?;
    # true if this inbound domain has successfully set up an MX record to deliver mail to the Mandrill servers
    @jsondata:Name {value: "valid_mx"}
    boolean validMx?;
    # the date and time that the inbound domain was added as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
};

# the updated mailbox route information
public type InlineResponse20014 record {
    # the search pattern that the mailbox name should match
    string pattern?;
    # the unique identifier of the route
    string id?;
    # the webhook URL where inbound messages will be published
    string url?;
};

public type InboundDeleteRouteBody record {
    # the unique identifier of an existing route
    string id;
    # a valid api key
    string 'key;
};

# information on an individual open
public type MessagessearchOpensDetail record {
    # the IP address that generated the open
    string ip?;
    # the approximate region and country that the opening IP is located
    string location?;
    # the email client or browser data of the open
    string ua?;
    # the unix timestamp from when the message was opened
    int ts?;
};

# a single merge variable
public type TemplatesrenderMergeVars record {
    # the merge variable's name. Merge variable names are case-insensitive and may not start with _
    string name?;
    # the merge variable's content
    string content?;
};

# the added mailbox route information
public type InlineResponse20013 record {
    # the search pattern that the mailbox name should match
    string pattern?;
    # the unique identifier of the route
    string id?;
    # the webhook URL where inbound messages will be published
    string url?;
};

# the individual recipient information
public type InlineResponse20016 record {
    # the mailbox route pattern that the recipient matched
    string pattern?;
    # the email address of the matching recipient
    string email?;
    # the webhook URL that the message was posted to
    string url?;
};

# the deleted mailbox route information
public type InlineResponse20015 record {
    # the search pattern that the mailbox name should match
    string pattern?;
    # the unique identifier of the route
    string id?;
    # the webhook URL where inbound messages will be published
    string url?;
};

# Information about the dedicated ip
public type InlineResponse20018 record {
    @jsondata:Name {value: "custom_dns"}
    IpslistCustomDns customDns?;
    # the ip address
    string ip?;
    # the domain name (reverse dns) of this dedicated IP
    string domain?;
    # the name of the pool that this dedicated IP belongs to
    string pool?;
    # the date and time that the dedicated IP was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # information about the ip's warmup status
    IpslistWarmup warmup?;
};

# information about a single dedicated IP
public type InlineResponse20017 record {
    @jsondata:Name {value: "custom_dns"}
    IpslistCustomDns customDns?;
    # the ip address
    string ip?;
    # the domain name (reverse dns) of this dedicated IP
    string domain?;
    # the name of the pool that this dedicated IP belongs to
    string pool?;
    # the date and time that the dedicated IP was created as a UTC string in YYYY-MM-DD HH:MM:SS format
    @jsondata:Name {value: "created_at"}
    string createdAt?;
    # information about the ip's warmup status
    IpslistWarmup warmup?;
};
